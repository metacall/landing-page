\doxysection{metacall.\+h File Reference}
\label{metacall_8h}\index{metacall.h@{metacall.h}}
{\ttfamily \#include $<$metacall/metacall\+\_\+api.\+h$>$}\newline
{\ttfamily \#include $<$metacall/metacall\+\_\+allocator.\+h$>$}\newline
{\ttfamily \#include $<$metacall/metacall\+\_\+def.\+h$>$}\newline
{\ttfamily \#include $<$metacall/metacall\+\_\+error.\+h$>$}\newline
{\ttfamily \#include $<$metacall/metacall\+\_\+log.\+h$>$}\newline
{\ttfamily \#include $<$metacall/metacall\+\_\+value.\+h$>$}\newline
{\ttfamily \#include $<$metacall/metacall\+\_\+version.\+h$>$}\newline
{\ttfamily \#include $<$stdarg.\+h$>$}\newline
{\ttfamily \#include $<$stdint.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
Include dependency graph for metacall.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{metacall_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=140pt]{metacall_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ metacall\+\_\+initialize\+\_\+configuration\+\_\+type}
\item 
struct \textbf{ metacall\+\_\+await\+\_\+callbacks}
\item 
struct \textbf{ metacall\+\_\+version\+\_\+type}
\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ METACALL\+\_\+\+FLAGS\+\_\+\+FORK\+\_\+\+SAFE}~0x01 $<$$<$ 0x00
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef void $\ast$($\ast$ \textbf{ metacall\+\_\+await\+\_\+callback}) (void $\ast$, void $\ast$)
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
METACALL\+\_\+\+API const char $\ast$ \textbf{ metacall\+\_\+serial} (void)
\item 
METACALL\+\_\+\+API void \textbf{ metacall\+\_\+log\+\_\+null} (void)
\item 
METACALL\+\_\+\+API void \textbf{ metacall\+\_\+flags} (int flags)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+initialize} (void)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+initialize\+\_\+ex} (struct \textbf{ metacall\+\_\+initialize\+\_\+configuration\+\_\+type} initialize\+\_\+config[$\,$])
\item 
METACALL\+\_\+\+API void \textbf{ metacall\+\_\+initialize\+\_\+args} (int argc, char $\ast$argv[$\,$])
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+argc} (void)
\item 
METACALL\+\_\+\+API char $\ast$$\ast$ \textbf{ metacall\+\_\+argv} (void)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+is\+\_\+initialized} (const char $\ast$tag)
\item 
METACALL\+\_\+\+API size\+\_\+t \textbf{ metacall\+\_\+args\+\_\+size} (void)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+execution\+\_\+path} (const char $\ast$tag, const char $\ast$path)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+execution\+\_\+path\+\_\+s} (const char $\ast$tag, size\+\_\+t tag\+\_\+length, const char $\ast$path, size\+\_\+t path\+\_\+length)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+load\+\_\+from\+\_\+file} (const char $\ast$tag, const char $\ast$paths[$\,$], size\+\_\+t size, void $\ast$$\ast$handle)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+load\+\_\+from\+\_\+memory} (const char $\ast$tag, const char $\ast$buffer, size\+\_\+t size, void $\ast$$\ast$handle)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+load\+\_\+from\+\_\+package} (const char $\ast$tag, const char $\ast$path, void $\ast$$\ast$handle)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+load\+\_\+from\+\_\+configuration} (const char $\ast$path, void $\ast$$\ast$handle, void $\ast$allocator)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallv} (const char $\ast$name, void $\ast$args[$\,$])
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallv\+\_\+s} (const char $\ast$name, void $\ast$args[$\,$], size\+\_\+t size)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallhv} (void $\ast$handle, const char $\ast$name, void $\ast$args[$\,$])
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallhv\+\_\+s} (void $\ast$handle, const char $\ast$name, void $\ast$args[$\,$], size\+\_\+t size)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall} (const char $\ast$name,...)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallt} (const char $\ast$name, const enum \textbf{ metacall\+\_\+value\+\_\+id} ids[$\,$],...)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallt\+\_\+s} (const char $\ast$name, const enum \textbf{ metacall\+\_\+value\+\_\+id} ids[$\,$], size\+\_\+t size,...)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallht\+\_\+s} (void $\ast$handle, const char $\ast$name, const enum \textbf{ metacall\+\_\+value\+\_\+id} ids[$\,$], size\+\_\+t size,...)
\end{DoxyCompactItemize}
\textbf{ }\par
{\em Get the function by


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Function reference, null if the function does not exist 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+function} (const char $\ast$name)
\end{DoxyCompactItemize}

\textbf{ }\par
{\em Create an empty handler into a loader with name


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em loader} & Pointer to the loader which the handle belongs to\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the handle\\
\hline
\mbox{\texttt{ out}}  & {\em handle\+\_\+ptr} & On success, returns the pointer to the handle created, otherwise NULL\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return zero on success, different from zero on error 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+handle\+\_\+initialize} (void $\ast$\textbf{ loader}, const char $\ast$name, void $\ast$$\ast$handle\+\_\+ptr)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+handle\+\_\+populate} (void $\ast$handle\+\_\+dest, void $\ast$handle\+\_\+src)
\end{DoxyCompactItemize}

\begin{Indent}\textbf{ from @handle}\par
{\em Get the function by


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em handle} & Pointer to the handle returned by metacall\+\_\+load\+\_\+from\+\_\+\{file, memory, package\}\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Function reference, null if the function does not exist 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+handle\+\_\+function} (void $\ast$handle, const char $\ast$name)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+function\+\_\+parameter\+\_\+type} (void $\ast$func, size\+\_\+t parameter, enum \textbf{ metacall\+\_\+value\+\_\+id} $\ast$id)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+function\+\_\+return\+\_\+type} (void $\ast$func, enum \textbf{ metacall\+\_\+value\+\_\+id} $\ast$id)
\item 
METACALL\+\_\+\+API size\+\_\+t \textbf{ metacall\+\_\+function\+\_\+size} (void $\ast$func)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+function\+\_\+async} (void $\ast$func)
\end{DoxyCompactItemize}
\end{Indent}
\textbf{ }\par
{\em Get the handle by


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tag} & Extension of the script\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the handle\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Handle reference, null if the function does not exist 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+handle} (const char $\ast$tag, const char $\ast$name)
\item 
METACALL\+\_\+\+API const char $\ast$ \textbf{ metacall\+\_\+handle\+\_\+id} (void $\ast$handle)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+handle\+\_\+export} (void $\ast$handle)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfv} (void $\ast$func, void $\ast$args[$\,$])
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfv\+\_\+s} (void $\ast$func, void $\ast$args[$\,$], size\+\_\+t size)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallf} (void $\ast$func,...)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfs} (void $\ast$func, const char $\ast$buffer, size\+\_\+t size, void $\ast$allocator)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfmv} (void $\ast$func, void $\ast$keys[$\,$], void $\ast$values[$\,$])
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfms} (void $\ast$func, const char $\ast$buffer, size\+\_\+t size, void $\ast$allocator)
\end{DoxyCompactItemize}

\begin{Indent}\textbf{ and arguments @va\+\_\+args}\par
{\em Register a function by name


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the function (if it is NULL, function is not registered into host scope)\\
\hline
\mbox{\texttt{ in}}  & {\em invoke} & Pointer to function invoke interface (argc, argv, data)\\
\hline
\mbox{\texttt{ out}}  & {\em func} & Will set the pointer to the function if the parameter is not null\\
\hline
\mbox{\texttt{ in}}  & {\em return\+\_\+type} & Type of return value\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of function arguments\\
\hline
\mbox{\texttt{ in}}  & {\em va\+\_\+args} & Varidic function parameter types\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+register} (const char $\ast$name, void $\ast$($\ast$invoke)(size\+\_\+t, void $\ast$[$\,$], void $\ast$), void $\ast$$\ast$func, enum \textbf{ metacall\+\_\+value\+\_\+id} return\+\_\+type, size\+\_\+t size,...)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ and arguments @types}\par
{\em Register a function by name


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em loader} & Opaque pointer to the loader in which you want to register the function (this allows to register the function into a different loader than the host)\\
\hline
\mbox{\texttt{ in}}  & {\em handle} & Opaque pointer to the handle in which you want to register the function (if it is NULL, it will be defined on the global scope of the loader)\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the function (if it is NULL, function is not registered into host scope)\\
\hline
\mbox{\texttt{ in}}  & {\em invoke} & Pointer to function invoke interface (argc, argv, data)\\
\hline
\mbox{\texttt{ in}}  & {\em return\+\_\+type} & Type of return value\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of function arguments\\
\hline
\mbox{\texttt{ in}}  & {\em types} & List of parameter types\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if the function was registered properly, distinct from zero otherwise 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+registerv} (const char $\ast$name, void $\ast$($\ast$invoke)(size\+\_\+t, void $\ast$[$\,$], void $\ast$), void $\ast$$\ast$func, enum \textbf{ metacall\+\_\+value\+\_\+id} return\+\_\+type, size\+\_\+t size, enum \textbf{ metacall\+\_\+value\+\_\+id} types[$\,$])
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+loader} (const char $\ast$tag)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+register\+\_\+loaderv} (void $\ast$\textbf{ loader}, void $\ast$handle, const char $\ast$name, void $\ast$($\ast$invoke)(size\+\_\+t, void $\ast$[$\,$], void $\ast$), enum \textbf{ metacall\+\_\+value\+\_\+id} return\+\_\+type, size\+\_\+t size, enum \textbf{ metacall\+\_\+value\+\_\+id} types[$\,$])
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+await} (const char $\ast$name, void $\ast$args[$\,$], void $\ast$($\ast$resolve\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$($\ast$reject\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$data)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+await\+\_\+future} (void $\ast$f, void $\ast$($\ast$resolve\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$($\ast$reject\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$data)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+await\+\_\+s} (const char $\ast$name, void $\ast$args[$\,$], size\+\_\+t size, void $\ast$($\ast$resolve\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$($\ast$reject\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$data)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfv\+\_\+await} (void $\ast$func, void $\ast$args[$\,$], void $\ast$($\ast$resolve\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$($\ast$reject\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$data)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfv\+\_\+await\+\_\+s} (void $\ast$func, void $\ast$args[$\,$], size\+\_\+t size, void $\ast$($\ast$resolve\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$($\ast$reject\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$data)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfv\+\_\+await\+\_\+struct\+\_\+s} (void $\ast$func, void $\ast$args[$\,$], size\+\_\+t size, \textbf{ metacall\+\_\+await\+\_\+callbacks} cb, void $\ast$data)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfmv\+\_\+await} (void $\ast$func, void $\ast$keys[$\,$], void $\ast$values[$\,$], void $\ast$($\ast$resolve\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$($\ast$reject\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$data)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfmv\+\_\+await\+\_\+s} (void $\ast$func, void $\ast$keys[$\,$], void $\ast$values[$\,$], size\+\_\+t size, void $\ast$($\ast$resolve\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$($\ast$reject\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$data)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfs\+\_\+await} (void $\ast$func, const char $\ast$buffer, size\+\_\+t size, void $\ast$allocator, void $\ast$($\ast$resolve\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$($\ast$reject\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$data)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallfms\+\_\+await} (void $\ast$func, const char $\ast$buffer, size\+\_\+t size, void $\ast$allocator, void $\ast$($\ast$resolve\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$($\ast$reject\+\_\+callback)(void $\ast$, void $\ast$), void $\ast$data)
\end{DoxyCompactItemize}
\end{Indent}
\textbf{ }\par
{\em Get the class by


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the class\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Class reference, null if the class does not exist 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+class} (const char $\ast$name)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallv\+\_\+class} (void $\ast$cls, const char $\ast$name, void $\ast$args[$\,$], size\+\_\+t size)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallt\+\_\+class} (void $\ast$cls, const char $\ast$name, const enum \textbf{ metacall\+\_\+value\+\_\+id} ret, void $\ast$args[$\,$], size\+\_\+t size)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+class\+\_\+new} (void $\ast$cls, const char $\ast$name, void $\ast$args[$\,$], size\+\_\+t size)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+class\+\_\+static\+\_\+get} (void $\ast$cls, const char $\ast$key)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+class\+\_\+static\+\_\+set} (void $\ast$cls, const char $\ast$key, void $\ast$v)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallv\+\_\+object} (void $\ast$obj, const char $\ast$name, void $\ast$args[$\,$], size\+\_\+t size)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacallt\+\_\+object} (void $\ast$obj, const char $\ast$name, const enum \textbf{ metacall\+\_\+value\+\_\+id} ret, void $\ast$args[$\,$], size\+\_\+t size)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+object\+\_\+get} (void $\ast$obj, const char $\ast$key)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+object\+\_\+set} (void $\ast$obj, const char $\ast$key, void $\ast$v)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+throwable\+\_\+value} (void $\ast$th)
\item 
METACALL\+\_\+\+API char $\ast$ \textbf{ metacall\+\_\+inspect} (size\+\_\+t $\ast$size, void $\ast$allocator)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+inspect\+\_\+value} (void)
\item 
METACALL\+\_\+\+API char $\ast$ \textbf{ metacall\+\_\+serialize} (const char $\ast$name, void $\ast$v, size\+\_\+t $\ast$size, void $\ast$allocator)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+deserialize} (const char $\ast$name, const char $\ast$buffer, size\+\_\+t size, void $\ast$allocator)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+clear} (void $\ast$handle)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+plugin\+\_\+extension} (void)
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+plugin\+\_\+core} (void)
\item 
METACALL\+\_\+\+API const char $\ast$ \textbf{ metacall\+\_\+plugin\+\_\+path} (void)
\item 
METACALL\+\_\+\+API int \textbf{ metacall\+\_\+destroy} (void)
\item 
METACALL\+\_\+\+API const struct \textbf{ metacall\+\_\+version\+\_\+type} $\ast$ \textbf{ metacall\+\_\+version} (void)
\item 
METACALL\+\_\+\+API uint32\+\_\+t \textbf{ metacall\+\_\+version\+\_\+hex\+\_\+make} (unsigned int major, unsigned int minor, unsigned int patch)
\item 
METACALL\+\_\+\+API uint32\+\_\+t \textbf{ metacall\+\_\+version\+\_\+hex} (void)
\item 
METACALL\+\_\+\+API const char $\ast$ \textbf{ metacall\+\_\+version\+\_\+str} (void)
\item 
METACALL\+\_\+\+API const char $\ast$ \textbf{ metacall\+\_\+version\+\_\+revision} (void)
\item 
METACALL\+\_\+\+API const char $\ast$ \textbf{ metacall\+\_\+version\+\_\+name} (void)
\item 
METACALL\+\_\+\+API const char $\ast$ \textbf{ metacall\+\_\+print\+\_\+info} (void)
\end{DoxyCompactItemize}

\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
METACALL\+\_\+\+API void $\ast$ \textbf{ metacall\+\_\+null\+\_\+args} [1]
\end{DoxyCompactItemize}


\doxysubsection{Macro Definition Documentation}
\mbox{\label{metacall_8h_a9c8f9f1a02aa8b7f11203f473ad45a0c}} 
\index{metacall.h@{metacall.h}!METACALL\_FLAGS\_FORK\_SAFE@{METACALL\_FLAGS\_FORK\_SAFE}}
\index{METACALL\_FLAGS\_FORK\_SAFE@{METACALL\_FLAGS\_FORK\_SAFE}!metacall.h@{metacall.h}}
\doxysubsubsection{METACALL\_FLAGS\_FORK\_SAFE}
{\footnotesize\ttfamily \#define METACALL\+\_\+\+FLAGS\+\_\+\+FORK\+\_\+\+SAFE~0x01 $<$$<$ 0x00}



\doxysubsection{Typedef Documentation}
\mbox{\label{metacall_8h_aa9b6fcb756e3ac95f638f4a42bb8f5d4}} 
\index{metacall.h@{metacall.h}!metacall\_await\_callback@{metacall\_await\_callback}}
\index{metacall\_await\_callback@{metacall\_await\_callback}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_await\_callback}
{\footnotesize\ttfamily typedef void$\ast$($\ast$ metacall\+\_\+await\+\_\+callback) (void $\ast$, void $\ast$)}



\doxysubsection{Function Documentation}
\mbox{\label{metacall_8h_adf5d6e87973ec71e38292324d0fd8048}} 
\index{metacall.h@{metacall.h}!metacall\_serial@{metacall\_serial}}
\index{metacall\_serial@{metacall\_serial}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_serial()}
{\footnotesize\ttfamily METACALL\+\_\+\+API const char$\ast$ metacall\+\_\+serial (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Returns default serializer used by Meta\+Call. 

\begin{DoxyReturn}{Returns}
Name of the serializer to be used with serialization methods 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a7359cf8608ee329433d129f74621f6b7}} 
\index{metacall.h@{metacall.h}!metacall\_log\_null@{metacall\_log\_null}}
\index{metacall\_log\_null@{metacall\_log\_null}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_log\_null()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void metacall\+\_\+log\+\_\+null (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Disables Meta\+Call logs, must be called before @metacall\+\_\+initialize. 

When initializing Meta\+Call, it initializes a default logs to stdout if none was defined. If you want to benchmark or simply disable this default logs, you can call to this function before @metacall\+\_\+initialize. \mbox{\label{metacall_8h_a59ae3eea97bc40256b292aea7f36b61c}} 
\index{metacall.h@{metacall.h}!metacall\_flags@{metacall\_flags}}
\index{metacall\_flags@{metacall\_flags}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_flags()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void metacall\+\_\+flags (\begin{DoxyParamCaption}\item[{int}]{flags }\end{DoxyParamCaption})}



Flags to be set in Meta\+Call library. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em flags} & Combination of flags referring to definitions METACALL\+\_\+\+FLAGS\+\_\+$\ast$ \\
\hline
\end{DoxyParams}
\mbox{\label{metacall_8h_aef066c5638c4e049288d98911e1a799f}} 
\index{metacall.h@{metacall.h}!metacall\_initialize@{metacall\_initialize}}
\index{metacall\_initialize@{metacall\_initialize}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_initialize()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+initialize (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Initialize Meta\+Call library. 

\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a9c70099ab9944bc953ff0998fa92f97e}} 
\index{metacall.h@{metacall.h}!metacall\_initialize\_ex@{metacall\_initialize\_ex}}
\index{metacall\_initialize\_ex@{metacall\_initialize\_ex}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_initialize\_ex()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+initialize\+\_\+ex (\begin{DoxyParamCaption}\item[{struct \textbf{ metacall\+\_\+initialize\+\_\+configuration\+\_\+type}}]{initialize\+\_\+config[$\,$] }\end{DoxyParamCaption})}



Initialize Meta\+Call library with configuration arguments. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em initialize\+\_\+config} & Extension of the script to be loaded in memory with data to be injected\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ab2759ffd9206401b14fb75d53bf35987}} 
\index{metacall.h@{metacall.h}!metacall\_initialize\_args@{metacall\_initialize\_args}}
\index{metacall\_initialize\_args@{metacall\_initialize\_args}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_initialize\_args()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void metacall\+\_\+initialize\+\_\+args (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char $\ast$}]{argv[$\,$] }\end{DoxyParamCaption})}



Initialize Meta\+Call application arguments. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em argc} & Number of additional parameters to be passed to the runtime when initializing\\
\hline
\mbox{\texttt{ in}}  & {\em argv} & Additional parameters to be passed to the runtime when initializing (when using Meta\+Call as an application) \\
\hline
\end{DoxyParams}
\mbox{\label{metacall_8h_a881a9d10167e78461635f285a788816c}} 
\index{metacall.h@{metacall.h}!metacall\_argc@{metacall\_argc}}
\index{metacall\_argc@{metacall\_argc}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_argc()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+argc (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Get the number of arguments in which Meta\+Call was initialized. 

\begin{DoxyReturn}{Returns}
An integer equal or greater than zero 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a9c0bd7df095d9a4db05204f04fa657a3}} 
\index{metacall.h@{metacall.h}!metacall\_argv@{metacall\_argv}}
\index{metacall\_argv@{metacall\_argv}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_argv()}
{\footnotesize\ttfamily METACALL\+\_\+\+API char$\ast$$\ast$ metacall\+\_\+argv (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Get the arguments in which Meta\+Call was initialized. 

\begin{DoxyReturn}{Returns}
A pointer to an array of strings with the additional arguments 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a6e9924c55b771ae7f80d6b153ad412d3}} 
\index{metacall.h@{metacall.h}!metacall\_is\_initialized@{metacall\_is\_initialized}}
\index{metacall\_is\_initialized@{metacall\_is\_initialized}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_is\_initialized()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+is\+\_\+initialized (\begin{DoxyParamCaption}\item[{const char $\ast$}]{tag }\end{DoxyParamCaption})}



Check if script context is loaded by @tag. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tag} & Extension of the script (if tag is NULL, it returns the status of the whole Meta\+Call instance)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if context is initialized, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_af773258f002ae5ea241b945ae4315d49}} 
\index{metacall.h@{metacall.h}!metacall\_args\_size@{metacall\_args\_size}}
\index{metacall\_args\_size@{metacall\_args\_size}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_args\_size()}
{\footnotesize\ttfamily METACALL\+\_\+\+API size\+\_\+t metacall\+\_\+args\+\_\+size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Amount of function call arguments supported by Meta\+Call. 

\begin{DoxyReturn}{Returns}
Number of arguments suported 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a14bbd56502b7bdd53fdbe42b46aceb16}} 
\index{metacall.h@{metacall.h}!metacall\_execution\_path@{metacall\_execution\_path}}
\index{metacall\_execution\_path@{metacall\_execution\_path}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_execution\_path()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+execution\+\_\+path (\begin{DoxyParamCaption}\item[{const char $\ast$}]{tag,  }\item[{const char $\ast$}]{path }\end{DoxyParamCaption})}



Set a execution path defined by @path to the extension script @tag. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tag} & Extension of the script\\
\hline
\mbox{\texttt{ in}}  & {\em path} & Path to be loaded\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ab6fd858391d840206fe14725c2b695e2}} 
\index{metacall.h@{metacall.h}!metacall\_execution\_path\_s@{metacall\_execution\_path\_s}}
\index{metacall\_execution\_path\_s@{metacall\_execution\_path\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_execution\_path\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+execution\+\_\+path\+\_\+s (\begin{DoxyParamCaption}\item[{const char $\ast$}]{tag,  }\item[{size\+\_\+t}]{tag\+\_\+length,  }\item[{const char $\ast$}]{path,  }\item[{size\+\_\+t}]{path\+\_\+length }\end{DoxyParamCaption})}



Set a execution path defined by @path to the extension script @tag with length. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tag} & Extension of the script\\
\hline
\mbox{\texttt{ in}}  & {\em tag\+\_\+length} & Length of the extension of the tag\\
\hline
\mbox{\texttt{ in}}  & {\em path} & Path to be loaded\\
\hline
\mbox{\texttt{ in}}  & {\em path\+\_\+length} & Length of the path\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a4cf8160c6bdd7c5c2614b40be31ce887}} 
\index{metacall.h@{metacall.h}!metacall\_load\_from\_file@{metacall\_load\_from\_file}}
\index{metacall\_load\_from\_file@{metacall\_load\_from\_file}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_load\_from\_file()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+load\+\_\+from\+\_\+file (\begin{DoxyParamCaption}\item[{const char $\ast$}]{tag,  }\item[{const char $\ast$}]{paths[$\,$],  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$$\ast$}]{handle }\end{DoxyParamCaption})}



Loads a script from file specified by @path. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tag} & Extension of the script\\
\hline
\mbox{\texttt{ in}}  & {\em paths} & Path array of files\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Size of the array @paths\\
\hline
\mbox{\texttt{ in,out}}  & {\em handle} & Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are propagated to the loader scope (i.\+e they will share the scope between all previously loaded files and they can collide). Otherwise, if we pass a void$\ast$ pointer set to NULL, it will behave as output parameter, obtaining the reference to the created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated handle (i.\+e a void$\ast$ pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated to the previously allocated handle, and it will behave as a in parameter.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_aa202ac4aeb04129ab475099af696b7b8}} 
\index{metacall.h@{metacall.h}!metacall\_load\_from\_memory@{metacall\_load\_from\_memory}}
\index{metacall\_load\_from\_memory@{metacall\_load\_from\_memory}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_load\_from\_memory()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+load\+\_\+from\+\_\+memory (\begin{DoxyParamCaption}\item[{const char $\ast$}]{tag,  }\item[{const char $\ast$}]{buffer,  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$$\ast$}]{handle }\end{DoxyParamCaption})}



Loads a script from memory. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tag} & Extension of the script\\
\hline
\mbox{\texttt{ in}}  & {\em buffer} & Memory block representing the string of the script\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Memory block representing the string of the script\\
\hline
\mbox{\texttt{ in,out}}  & {\em handle} & Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are propagated to the loader scope (i.\+e they will share the scope between all previously loaded files and they can collide). Otherwise, if we pass a void$\ast$ pointer set to NULL, it will behave as output parameter, obtaining the reference to the created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated handle (i.\+e a void$\ast$ pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated to the previously allocated handle, and it will behave as a in parameter.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ae62d509141fe85874f1865f61b4075af}} 
\index{metacall.h@{metacall.h}!metacall\_load\_from\_package@{metacall\_load\_from\_package}}
\index{metacall\_load\_from\_package@{metacall\_load\_from\_package}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_load\_from\_package()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+load\+\_\+from\+\_\+package (\begin{DoxyParamCaption}\item[{const char $\ast$}]{tag,  }\item[{const char $\ast$}]{path,  }\item[{void $\ast$$\ast$}]{handle }\end{DoxyParamCaption})}



Loads a package of scrips from file specified by @path into loader defined by @extension. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tag} & Extension of the script\\
\hline
\mbox{\texttt{ in}}  & {\em path} & Path of the package\\
\hline
\mbox{\texttt{ in,out}}  & {\em handle} & Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are propagated to the loader scope (i.\+e they will share the scope between all previously loaded files and they can collide). Otherwise, if we pass a void$\ast$ pointer set to NULL, it will behave as output parameter, obtaining the reference to the created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated handle (i.\+e a void$\ast$ pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated to the previously allocated handle, and it will behave as a in parameter.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a00a0cad16a66aaaab0f2e523ee390be3}} 
\index{metacall.h@{metacall.h}!metacall\_load\_from\_configuration@{metacall\_load\_from\_configuration}}
\index{metacall\_load\_from\_configuration@{metacall\_load\_from\_configuration}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_load\_from\_configuration()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+load\+\_\+from\+\_\+configuration (\begin{DoxyParamCaption}\item[{const char $\ast$}]{path,  }\item[{void $\ast$$\ast$}]{handle,  }\item[{void $\ast$}]{allocator }\end{DoxyParamCaption})}



Loads a a list of scrips from configuration specified by @path into loader with the following format\+: \{ \char`\"{}language\+\_\+id\char`\"{}\+: \char`\"{}$<$tag$>$\char`\"{}, \char`\"{}path\char`\"{}\+: \char`\"{}$<$path$>$\char`\"{}, \char`\"{}scripts\char`\"{}\+: [ \char`\"{}$<$script0$>$\char`\"{}, \char`\"{}$<$script1$>$\char`\"{}, ..., \char`\"{}$<$script\+N$>$\char`\"{} ] \}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em path} & Path of the configuration\\
\hline
\mbox{\texttt{ in,out}}  & {\em handle} & Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are propagated to the loader scope (i.\+e they will share the scope between all previously loaded files and they can collide). Otherwise, if we pass a void$\ast$ pointer set to NULL, it will behave as output parameter, obtaining the reference to the created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated handle (i.\+e a void$\ast$ pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated to the previously allocated handle, and it will behave as a in parameter.\\
\hline
\mbox{\texttt{ in}}  & {\em allocator} & Pointer to allocator will allocate the configuration\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_afc2c0d0a24b9f6e4908bbac36d98954b}} 
\index{metacall.h@{metacall.h}!metacallv@{metacallv}}
\index{metacallv@{metacallv}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallv()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallv (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{args[$\,$] }\end{DoxyParamCaption})}



Call a function anonymously by value array @args. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ad934b33c0c04c424d7080735d86a240c}} 
\index{metacall.h@{metacall.h}!metacallv\_s@{metacallv\_s}}
\index{metacallv\_s@{metacallv\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallv\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallv\+\_\+s (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Call a function anonymously by value array @args. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of the call\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_abaa8b58b55e753ebcb2c6ca7221261fe}} 
\index{metacall.h@{metacall.h}!metacallhv@{metacallhv}}
\index{metacallhv@{metacallhv}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallhv()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallhv (\begin{DoxyParamCaption}\item[{void $\ast$}]{handle,  }\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{args[$\,$] }\end{DoxyParamCaption})}



Call a function anonymously by handle @handle value array @args This function allows to avoid name collisions when calling functions by name. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em handle} & Handle where the function belongs\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a0973f34ae8081817abbcc84e54b09fcc}} 
\index{metacall.h@{metacall.h}!metacallhv\_s@{metacallhv\_s}}
\index{metacallhv\_s@{metacallhv\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallhv\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallhv\+\_\+s (\begin{DoxyParamCaption}\item[{void $\ast$}]{handle,  }\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Call a function anonymously by handle @handle value array @args This function allows to avoid name collisions when calling functions by name Includes @size in order to allow variadic arguments or safe calls. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em handle} & Handle where the function belongs\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of the call\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a927b07b0d76019322c9a84a768333be7}} 
\index{metacall.h@{metacall.h}!metacall@{metacall}}
\index{metacall@{metacall}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{}]{... }\end{DoxyParamCaption})}



Call a function anonymously by variable arguments @va\+\_\+args. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\mbox{\texttt{ in}}  & {\em va\+\_\+args} & Varidic function parameters\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a3d6052ad320dd2bb83d6c39d7bac3a1e}} 
\index{metacall.h@{metacall.h}!metacallt@{metacallt}}
\index{metacallt@{metacallt}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallt()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallt (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{const enum \textbf{ metacall\+\_\+value\+\_\+id}}]{ids[$\,$],  }\item[{}]{... }\end{DoxyParamCaption})}



Call a function anonymously by type array @ids and variable arguments @va\+\_\+args. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\mbox{\texttt{ in}}  & {\em ids} & Array of types refered to @va\+\_\+args\\
\hline
\mbox{\texttt{ in}}  & {\em va\+\_\+args} & Varidic function parameters\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a93e003693bcf043424e5bd77255ef629}} 
\index{metacall.h@{metacall.h}!metacallt\_s@{metacallt\_s}}
\index{metacallt\_s@{metacallt\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallt\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallt\+\_\+s (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{const enum \textbf{ metacall\+\_\+value\+\_\+id}}]{ids[$\,$],  }\item[{size\+\_\+t}]{size,  }\item[{}]{... }\end{DoxyParamCaption})}



Call a function anonymously by type array @ids and variable arguments @va\+\_\+args. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\mbox{\texttt{ in}}  & {\em ids} & Array of types refered to @va\+\_\+args\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of the call\\
\hline
\mbox{\texttt{ in}}  & {\em va\+\_\+args} & Varidic function parameters\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a020d72d3ec5fac1ef707e57e356ef0ea}} 
\index{metacall.h@{metacall.h}!metacallht\_s@{metacallht\_s}}
\index{metacallht\_s@{metacallht\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallht\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallht\+\_\+s (\begin{DoxyParamCaption}\item[{void $\ast$}]{handle,  }\item[{const char $\ast$}]{name,  }\item[{const enum \textbf{ metacall\+\_\+value\+\_\+id}}]{ids[$\,$],  }\item[{size\+\_\+t}]{size,  }\item[{}]{... }\end{DoxyParamCaption})}



Call a function anonymously by type array @ids and variable arguments @va\+\_\+args. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em handle} & Pointer to the handle returned by metacall\+\_\+load\+\_\+from\+\_\+\{file, memory, package\}\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the function\\
\hline
\mbox{\texttt{ in}}  & {\em ids} & Array of types refered to @va\+\_\+args\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of the call\\
\hline
\mbox{\texttt{ in}}  & {\em va\+\_\+args} & Varidic function parameters\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a137dbf351f620ac5c1daebf1564f099b}} 
\index{metacall.h@{metacall.h}!metacall\_function@{metacall\_function}}
\index{metacall\_function@{metacall\_function}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_function()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+function (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

\mbox{\label{metacall_8h_a792c94a85654f6463e924250acd9c72b}} 
\index{metacall.h@{metacall.h}!metacall\_handle\_initialize@{metacall\_handle\_initialize}}
\index{metacall\_handle\_initialize@{metacall\_handle\_initialize}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_handle\_initialize()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+handle\+\_\+initialize (\begin{DoxyParamCaption}\item[{void $\ast$}]{loader,  }\item[{const char $\ast$}]{name,  }\item[{void $\ast$$\ast$}]{handle\+\_\+ptr }\end{DoxyParamCaption})}

\mbox{\label{metacall_8h_a201abde4e06b9405ee6dd27c4c2f6d6c}} 
\index{metacall.h@{metacall.h}!metacall\_handle\_populate@{metacall\_handle\_populate}}
\index{metacall\_handle\_populate@{metacall\_handle\_populate}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_handle\_populate()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+handle\+\_\+populate (\begin{DoxyParamCaption}\item[{void $\ast$}]{handle\+\_\+dest,  }\item[{void $\ast$}]{handle\+\_\+src }\end{DoxyParamCaption})}



Populate the objects of @handle\+\_\+src into @handle\+\_\+dest. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em handle\+\_\+dest} & Handle where the objects from @handle\+\_\+src will be stored\\
\hline
\mbox{\texttt{ in}}  & {\em handle\+\_\+src} & Handle from where the objects will be copied\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return zero on success, different from zero on error 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a0733570d83d6daf0e421e3e414547566}} 
\index{metacall.h@{metacall.h}!metacall\_handle\_function@{metacall\_handle\_function}}
\index{metacall\_handle\_function@{metacall\_handle\_function}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_handle\_function()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+handle\+\_\+function (\begin{DoxyParamCaption}\item[{void $\ast$}]{handle,  }\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

\mbox{\label{metacall_8h_a26ff10520ec45fc6dc56e6b731f7cd98}} 
\index{metacall.h@{metacall.h}!metacall\_function\_parameter\_type@{metacall\_function\_parameter\_type}}
\index{metacall\_function\_parameter\_type@{metacall\_function\_parameter\_type}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_function\_parameter\_type()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+function\+\_\+parameter\+\_\+type (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{size\+\_\+t}]{parameter,  }\item[{enum \textbf{ metacall\+\_\+value\+\_\+id} $\ast$}]{id }\end{DoxyParamCaption})}



Get the function parameter type id. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & The pointer to the function obtained from metacall\+\_\+function\\
\hline
\mbox{\texttt{ in}}  & {\em parameter} & The index of the parameter to be retrieved\\
\hline
\mbox{\texttt{ out}}  & {\em id} & The parameter type id that will be returned\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return 0 if the @parameter index exists and @func is valid, 1 otherwhise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a391f6f382c453d8903889a910f59bf4c}} 
\index{metacall.h@{metacall.h}!metacall\_function\_return\_type@{metacall\_function\_return\_type}}
\index{metacall\_function\_return\_type@{metacall\_function\_return\_type}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_function\_return\_type()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+function\+\_\+return\+\_\+type (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{enum \textbf{ metacall\+\_\+value\+\_\+id} $\ast$}]{id }\end{DoxyParamCaption})}



Get the function return type id. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & The pointer to the function obtained from metacall\+\_\+function\\
\hline
\mbox{\texttt{ out}}  & {\em id} & The value id of the return type of the function @func\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return 0 if the @func is valid, 1 otherwhise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ae41ffa4531b7819e7f0d1c580ef508c5}} 
\index{metacall.h@{metacall.h}!metacall\_function\_size@{metacall\_function\_size}}
\index{metacall\_function\_size@{metacall\_function\_size}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_function\_size()}
{\footnotesize\ttfamily METACALL\+\_\+\+API size\+\_\+t metacall\+\_\+function\+\_\+size (\begin{DoxyParamCaption}\item[{void $\ast$}]{func }\end{DoxyParamCaption})}



Get minimun mumber of arguments accepted by function @func. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Function reference\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return mumber of arguments 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a42f7b6d24d91f6aa2b1a1bf773a2be3b}} 
\index{metacall.h@{metacall.h}!metacall\_function\_async@{metacall\_function\_async}}
\index{metacall\_function\_async@{metacall\_function\_async}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_function\_async()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+function\+\_\+async (\begin{DoxyParamCaption}\item[{void $\ast$}]{func }\end{DoxyParamCaption})}



Check if the function @func is asynchronous or synchronous. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Function reference\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return 0 if it is syncrhonous, 1 if it is asynchronous and -\/1 if the function is NULL 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a579d699c4407cc27e94d216303f152aa}} 
\index{metacall.h@{metacall.h}!metacall\_handle@{metacall\_handle}}
\index{metacall\_handle@{metacall\_handle}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_handle()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+handle (\begin{DoxyParamCaption}\item[{const char $\ast$}]{tag,  }\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

\mbox{\label{metacall_8h_a593872223a3cbbf9856ce9d9dc8ba2da}} 
\index{metacall.h@{metacall.h}!metacall\_handle\_id@{metacall\_handle\_id}}
\index{metacall\_handle\_id@{metacall\_handle\_id}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_handle\_id()}
{\footnotesize\ttfamily METACALL\+\_\+\+API const char$\ast$ metacall\+\_\+handle\+\_\+id (\begin{DoxyParamCaption}\item[{void $\ast$}]{handle }\end{DoxyParamCaption})}



Get name of a @handle. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em handle} & Pointer to the handle to be retrieved\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
String that references the handle 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ad69cc4988cf490c58d1c5d72ce7a3f95}} 
\index{metacall.h@{metacall.h}!metacall\_handle\_export@{metacall\_handle\_export}}
\index{metacall\_handle\_export@{metacall\_handle\_export}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_handle\_export()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+handle\+\_\+export (\begin{DoxyParamCaption}\item[{void $\ast$}]{handle }\end{DoxyParamCaption})}



Return a value representing the handle as a map of functions (or values) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em handle} & Reference to the handle to be described\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A value of type map on success, null otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a7029ce54bb2a8fb4516415e42d6d986b}} 
\index{metacall.h@{metacall.h}!metacallfv@{metacallfv}}
\index{metacallfv@{metacallfv}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfv()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfv (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{void $\ast$}]{args[$\,$] }\end{DoxyParamCaption})}



Call a function anonymously by value array @args and function @func. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_afcaf2d96cbe7e899e9f5450be7d7d1c4}} 
\index{metacall.h@{metacall.h}!metacallfv\_s@{metacallfv\_s}}
\index{metacallfv\_s@{metacallfv\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfv\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfv\+\_\+s (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Call a function anonymously by value array @args and function @func. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of function arguments\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ae523e9a658d5ea11bde72660df84df95}} 
\index{metacall.h@{metacall.h}!metacallf@{metacallf}}
\index{metacallf@{metacallf}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallf()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallf (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{}]{... }\end{DoxyParamCaption})}



Call a function anonymously by variable arguments @va\+\_\+args and function @func. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a6de5e0d836963404a27918bfade98cad}} 
\index{metacall.h@{metacall.h}!metacallfs@{metacallfs}}
\index{metacallfs@{metacallfs}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfs()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfs (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{const char $\ast$}]{buffer,  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$}]{allocator }\end{DoxyParamCaption})}



Call a function anonymously by function @func and serial @buffer of size @size. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em buffer} & String representing an array to be deserialized into arguments of the function\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Size of string @buffer\\
\hline
\mbox{\texttt{ in}}  & {\em allocator} & Pointer to allocator will allocate the value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ac1ecf16f1985cecee777d9e84c70d79a}} 
\index{metacall.h@{metacall.h}!metacallfmv@{metacallfmv}}
\index{metacallfmv@{metacallfmv}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfmv()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfmv (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{void $\ast$}]{keys[$\,$],  }\item[{void $\ast$}]{values[$\,$] }\end{DoxyParamCaption})}



Call a function anonymously by value map (@keys -\/$>$ @values) and function @func. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em keys} & Array of values representing argument keys\\
\hline
\mbox{\texttt{ in}}  & {\em values} & Array of values representing argument values data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ae381876c35f6b194c96c19a9b808e313}} 
\index{metacall.h@{metacall.h}!metacallfms@{metacallfms}}
\index{metacallfms@{metacallfms}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfms()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfms (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{const char $\ast$}]{buffer,  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$}]{allocator }\end{DoxyParamCaption})}



Call a function anonymously by function @func and serial @buffer of size @size. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em buffer} & String representing a map to be deserialized into arguments of the function\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Size of string @buffer\\
\hline
\mbox{\texttt{ in}}  & {\em allocator} & Pointer to allocator will allocate the value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a810ca74b8efef842df8ea7baf2b87e67}} 
\index{metacall.h@{metacall.h}!metacall\_register@{metacall\_register}}
\index{metacall\_register@{metacall\_register}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_register()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+register (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{void $\ast$($\ast$)(size\+\_\+t, void $\ast$[$\,$], void $\ast$)}]{invoke,  }\item[{void $\ast$$\ast$}]{func,  }\item[{enum \textbf{ metacall\+\_\+value\+\_\+id}}]{return\+\_\+type,  }\item[{size\+\_\+t}]{size,  }\item[{}]{... }\end{DoxyParamCaption})}

\mbox{\label{metacall_8h_ae0f575287847cd57f5a549b2b211db1d}} 
\index{metacall.h@{metacall.h}!metacall\_registerv@{metacall\_registerv}}
\index{metacall\_registerv@{metacall\_registerv}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_registerv()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+registerv (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{void $\ast$($\ast$)(size\+\_\+t, void $\ast$[$\,$], void $\ast$)}]{invoke,  }\item[{void $\ast$$\ast$}]{func,  }\item[{enum \textbf{ metacall\+\_\+value\+\_\+id}}]{return\+\_\+type,  }\item[{size\+\_\+t}]{size,  }\item[{enum \textbf{ metacall\+\_\+value\+\_\+id}}]{types[$\,$] }\end{DoxyParamCaption})}

\mbox{\label{metacall_8h_a5defaa7768a7d70a141930a5d7d8d4bf}} 
\index{metacall.h@{metacall.h}!metacall\_loader@{metacall\_loader}}
\index{metacall\_loader@{metacall\_loader}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_loader()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+loader (\begin{DoxyParamCaption}\item[{const char $\ast$}]{tag }\end{DoxyParamCaption})}



Obtain the loader instance by @tag. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tag} & Tag in which the loader is identified, normally it is the extension of the script\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer the loader by @tag 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a4d4b136ce9d1890593050e544f8bd59f}} 
\index{metacall.h@{metacall.h}!metacall\_register\_loaderv@{metacall\_register\_loaderv}}
\index{metacall\_register\_loaderv@{metacall\_register\_loaderv}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_register\_loaderv()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+register\+\_\+loaderv (\begin{DoxyParamCaption}\item[{void $\ast$}]{loader,  }\item[{void $\ast$}]{handle,  }\item[{const char $\ast$}]{name,  }\item[{void $\ast$($\ast$)(size\+\_\+t, void $\ast$[$\,$], void $\ast$)}]{invoke,  }\item[{enum \textbf{ metacall\+\_\+value\+\_\+id}}]{return\+\_\+type,  }\item[{size\+\_\+t}]{size,  }\item[{enum \textbf{ metacall\+\_\+value\+\_\+id}}]{types[$\,$] }\end{DoxyParamCaption})}

\mbox{\label{metacall_8h_a52ef2927638d958c6e76555fc49a765b}} 
\index{metacall.h@{metacall.h}!metacall\_await@{metacall\_await}}
\index{metacall\_await@{metacall\_await}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_await()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+await (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{args[$\,$],  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{resolve\+\_\+callback,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{reject\+\_\+callback,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Executes an asynchronous call to the function and registers a callback to be executed when a future is resolved (it does block) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the function to be called asynchronously\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to the values to be passed to the function\\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+callback} & Pointer to function that will be executed when task completion \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ Value representing the result of the future resolution \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ A reference to @data that will be used as a closure for the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reject\+\_\+callback} & Pointer to function that will be executed when task error (signature is identical as resolve\+\_\+callback)\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a5f24de215645b2728c80e20685cb5525}} 
\index{metacall.h@{metacall.h}!metacall\_await\_future@{metacall\_await\_future}}
\index{metacall\_await\_future@{metacall\_await\_future}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_await\_future()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+await\+\_\+future (\begin{DoxyParamCaption}\item[{void $\ast$}]{f,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{resolve\+\_\+callback,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{reject\+\_\+callback,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Awaits for a promise and registers a callback to be executed when a future is resolved. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em f} & The pointer to the future\\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+callback} & Pointer to function that will be executed when task completion \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ Value representing the result of the future resolution \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ A reference to @data that will be used as a closure for the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reject\+\_\+callback} & Pointer to function that will be executed when task error (signature is identical as resolve\+\_\+callback)\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a698f9b1a031af836302d2634e3194f75}} 
\index{metacall.h@{metacall.h}!metacall\_await\_s@{metacall\_await\_s}}
\index{metacall\_await\_s@{metacall\_await\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_await\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+await\+\_\+s (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{resolve\+\_\+callback,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{reject\+\_\+callback,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Executes an asynchronous call to the function and registers a callback to be executed when a future is resolved (it does block) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the function to be called asynchronously\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to the values to be passed to the function\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of the array @args\\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+callback} & Pointer to function that will be executed when task completion \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ Value representing the result of the future resolution \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ A reference to @data that will be used as a closure for the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reject\+\_\+callback} & Pointer to function that will be executed when task error (signature is identical as resolve\+\_\+callback)\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a4aae2677499d7bc7992840e90d754d83}} 
\index{metacall.h@{metacall.h}!metacallfv\_await@{metacallfv\_await}}
\index{metacallfv\_await@{metacallfv\_await}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfv\_await()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfv\+\_\+await (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{void $\ast$}]{args[$\,$],  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{resolve\+\_\+callback,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{reject\+\_\+callback,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Call an asynchronous function anonymously by value array @args and function @func. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to values\\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+callback} & Pointer to function that will be executed when task completion \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ Value representing the result of the future resolution \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ A reference to @data that will be used as a closure for the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reject\+\_\+callback} & Pointer to function that will be executed when task error (signature is identical as resolve\+\_\+callback)\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a9c5ead1f1aa559e58a65f69ae51972cb}} 
\index{metacall.h@{metacall.h}!metacallfv\_await\_s@{metacallfv\_await\_s}}
\index{metacallfv\_await\_s@{metacallfv\_await\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfv\_await\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfv\+\_\+await\+\_\+s (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{resolve\+\_\+callback,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{reject\+\_\+callback,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Call an asynchronous function anonymously by value array @args and function @func. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to values\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of the array @args\\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+callback} & Pointer to function that will be executed when task completion \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ Value representing the result of the future resolution \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ A reference to @data that will be used as a closure for the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reject\+\_\+callback} & Pointer to function that will be executed when task error (signature is identical as resolve\+\_\+callback)\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_afe71978aefb3bb4d664ddf54b5ab81b7}} 
\index{metacall.h@{metacall.h}!metacallfv\_await\_struct\_s@{metacallfv\_await\_struct\_s}}
\index{metacallfv\_await\_struct\_s@{metacallfv\_await\_struct\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfv\_await\_struct\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfv\+\_\+await\+\_\+struct\+\_\+s (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size,  }\item[{\textbf{ metacall\+\_\+await\+\_\+callbacks}}]{cb,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Call an asynchronous function anonymously by value array @args and function @func (offered without function pointers for languages without support to function pointers) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to values\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of the array @args\\
\hline
\mbox{\texttt{ in}}  & {\em cb} & Pointer to struct containing the function pointers to reject and resolve that will be executed when task completion or error\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a806b1dda95f596de33a9527123fed8e4}} 
\index{metacall.h@{metacall.h}!metacallfmv\_await@{metacallfmv\_await}}
\index{metacallfmv\_await@{metacallfmv\_await}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfmv\_await()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfmv\+\_\+await (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{void $\ast$}]{keys[$\,$],  }\item[{void $\ast$}]{values[$\,$],  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{resolve\+\_\+callback,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{reject\+\_\+callback,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Call an asynchronous function anonymously by value map (@keys -\/$>$ @values) and function @func. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em keys} & Array of values representing argument keys\\
\hline
\mbox{\texttt{ in}}  & {\em values} & Array of values representing argument values data\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of the arrays @keys and @values\\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+callback} & Pointer to function that will be executed when task completion \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ Value representing the result of the future resolution \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ A reference to @data that will be used as a closure for the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reject\+\_\+callback} & Pointer to function that will be executed when task error (signature is identical as resolve\+\_\+callback)\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a4c8d0fa0f6b7c3607bd92524a11f3c5c}} 
\index{metacall.h@{metacall.h}!metacallfmv\_await\_s@{metacallfmv\_await\_s}}
\index{metacallfmv\_await\_s@{metacallfmv\_await\_s}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfmv\_await\_s()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfmv\+\_\+await\+\_\+s (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{void $\ast$}]{keys[$\,$],  }\item[{void $\ast$}]{values[$\,$],  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{resolve\+\_\+callback,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{reject\+\_\+callback,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Call an asynchronous function anonymously by value map (@keys -\/$>$ @values) and function @func. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em keys} & Array of values representing argument keys\\
\hline
\mbox{\texttt{ in}}  & {\em values} & Array of values representing argument values data\\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+callback} & Pointer to function that will be executed when task completion \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ Value representing the result of the future resolution \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ A reference to @data that will be used as a closure for the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reject\+\_\+callback} & Pointer to function that will be executed when task error (signature is identical as resolve\+\_\+callback)\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_addd2e38b4966b41bc2473c172d52147d}} 
\index{metacall.h@{metacall.h}!metacallfs\_await@{metacallfs\_await}}
\index{metacallfs\_await@{metacallfs\_await}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfs\_await()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfs\+\_\+await (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{const char $\ast$}]{buffer,  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$}]{allocator,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{resolve\+\_\+callback,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{reject\+\_\+callback,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Call an asynchronous function anonymously by function @func and serial @buffer of size @size. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em buffer} & String representing an array to be deserialized into arguments of the function\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Size of string @buffer\\
\hline
\mbox{\texttt{ in}}  & {\em allocator} & Pointer to allocator will allocate the value\\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+callback} & Pointer to function that will be executed when task completion \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ Value representing the result of the future resolution \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ A reference to @data that will be used as a closure for the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reject\+\_\+callback} & Pointer to function that will be executed when task error (signature is identical as resolve\+\_\+callback)\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a6111e7af53fb3dcf04018aa7a06b01e3}} 
\index{metacall.h@{metacall.h}!metacallfms\_await@{metacallfms\_await}}
\index{metacallfms\_await@{metacallfms\_await}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallfms\_await()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallfms\+\_\+await (\begin{DoxyParamCaption}\item[{void $\ast$}]{func,  }\item[{const char $\ast$}]{buffer,  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$}]{allocator,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{resolve\+\_\+callback,  }\item[{void $\ast$($\ast$)(void $\ast$, void $\ast$)}]{reject\+\_\+callback,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}



Call an asynchronous function anonymously by function @func and serial @buffer of size @size. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em func} & Reference to function to be called\\
\hline
\mbox{\texttt{ in}}  & {\em buffer} & String representing a map to be deserialized into arguments of the function\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Size of string @buffer\\
\hline
\mbox{\texttt{ in}}  & {\em allocator} & Pointer to allocator will allocate the value\\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+callback} & Pointer to function that will be executed when task completion \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ Value representing the result of the future resolution \\
\hline
\mbox{\texttt{ in}}  & {\em void} & $\ast$ A reference to @data that will be used as a closure for the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em reject\+\_\+callback} & Pointer to function that will be executed when task error (signature is identical as resolve\+\_\+callback)\\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to a context that will act as a closure for the chain\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call returned by @resolve\+\_\+callback or @reject\+\_\+callback wrapped in a future 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a62422ba9010c261547585dc014f5f71f}} 
\index{metacall.h@{metacall.h}!metacall\_class@{metacall\_class}}
\index{metacall\_class@{metacall\_class}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_class()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+class (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

\mbox{\label{metacall_8h_a97f50d305c683edfbeec022d41d8b749}} 
\index{metacall.h@{metacall.h}!metacallv\_class@{metacallv\_class}}
\index{metacallv\_class@{metacallv\_class}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallv\_class()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallv\+\_\+class (\begin{DoxyParamCaption}\item[{void $\ast$}]{cls,  }\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Call a class method anonymously by value array @args (this procedure assumes there\textquotesingle{}s no overloaded methods and does type conversion on values) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cls} & Pointer to the class\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the method\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of args array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ac0e15e8ca121a9b0c5b1f22f760d7137}} 
\index{metacall.h@{metacall.h}!metacallt\_class@{metacallt\_class}}
\index{metacallt\_class@{metacallt\_class}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallt\_class()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallt\+\_\+class (\begin{DoxyParamCaption}\item[{void $\ast$}]{cls,  }\item[{const char $\ast$}]{name,  }\item[{const enum \textbf{ metacall\+\_\+value\+\_\+id}}]{ret,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Call a class method anonymously by value array @args and return value type @ret (helps to resolve overloading methods) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cls} & Pointer to the class\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the method\\
\hline
\mbox{\texttt{ in}}  & {\em ret} & Type of the return value of the method\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of args array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_aee922f6a17e2d304c8074342779205c1}} 
\index{metacall.h@{metacall.h}!metacall\_class\_new@{metacall\_class\_new}}
\index{metacall\_class\_new@{metacall\_class\_new}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_class\_new()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+class\+\_\+new (\begin{DoxyParamCaption}\item[{void $\ast$}]{cls,  }\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Create a new object instance from @cls by value array @args. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cls} & Pointer to the class\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the new object\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers constructor parameters\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of constructor parameters\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the new object value instance 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a70337e2f826dab637d640337404831cf}} 
\index{metacall.h@{metacall.h}!metacall\_class\_static\_get@{metacall\_class\_static\_get}}
\index{metacall\_class\_static\_get@{metacall\_class\_static\_get}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_class\_static\_get()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+class\+\_\+static\+\_\+get (\begin{DoxyParamCaption}\item[{void $\ast$}]{cls,  }\item[{const char $\ast$}]{key }\end{DoxyParamCaption})}



Get an attribute from @cls by @key name. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cls} & Pointer to the class\\
\hline
\mbox{\texttt{ in}}  & {\em key} & Name of the attribute to get\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the class attribute value or NULL if an error occurred 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ad69032d3eec3834b36d907141f32332a}} 
\index{metacall.h@{metacall.h}!metacall\_class\_static\_set@{metacall\_class\_static\_set}}
\index{metacall\_class\_static\_set@{metacall\_class\_static\_set}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_class\_static\_set()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+class\+\_\+static\+\_\+set (\begin{DoxyParamCaption}\item[{void $\ast$}]{cls,  }\item[{const char $\ast$}]{key,  }\item[{void $\ast$}]{v }\end{DoxyParamCaption})}



Set an attribute to @cls by @key name. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cls} & Pointer to the class\\
\hline
\mbox{\texttt{ in}}  & {\em key} & Name of the attribute to set\\
\hline
\mbox{\texttt{ in}}  & {\em value} & Value to set\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Non-\/zero integer if an error ocurred 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a1b346165cc3e9d4c958bf92c65f71ef5}} 
\index{metacall.h@{metacall.h}!metacallv\_object@{metacallv\_object}}
\index{metacallv\_object@{metacallv\_object}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallv\_object()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallv\+\_\+object (\begin{DoxyParamCaption}\item[{void $\ast$}]{obj,  }\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Call an object method anonymously by value array @args. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em obj} & Pointer to the object\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the method\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of args array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a1391d4d2e8f9dc919ecb6ce5ac00916f}} 
\index{metacall.h@{metacall.h}!metacallt\_object@{metacallt\_object}}
\index{metacallt\_object@{metacallt\_object}!metacall.h@{metacall.h}}
\doxysubsubsection{metacallt\_object()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacallt\+\_\+object (\begin{DoxyParamCaption}\item[{void $\ast$}]{obj,  }\item[{const char $\ast$}]{name,  }\item[{const enum \textbf{ metacall\+\_\+value\+\_\+id}}]{ret,  }\item[{void $\ast$}]{args[$\,$],  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Call a object method anonymously by value array @args and return value type @ret (helps to resolve overloading methods) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em obj} & Pointer to the object\\
\hline
\mbox{\texttt{ in}}  & {\em name} & Name of the method\\
\hline
\mbox{\texttt{ in}}  & {\em ret} & Type of the return value of the method\\
\hline
\mbox{\texttt{ in}}  & {\em args} & Array of pointers to data\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Number of elements of args array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to value containing the result of the call 
\end{DoxyReturn}
\mbox{\label{metacall_8h_abf765af19df6abca9ef981ed56db6b92}} 
\index{metacall.h@{metacall.h}!metacall\_object\_get@{metacall\_object\_get}}
\index{metacall\_object\_get@{metacall\_object\_get}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_object\_get()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+object\+\_\+get (\begin{DoxyParamCaption}\item[{void $\ast$}]{obj,  }\item[{const char $\ast$}]{key }\end{DoxyParamCaption})}



Get an attribute from @obj by @key name. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em obj} & Pointer to the object\\
\hline
\mbox{\texttt{ in}}  & {\em key} & Name of the attribute to get\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the object attribute value or NULL if an error occurred 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a567cbdd3c398e4bcfab8e07ff76de06b}} 
\index{metacall.h@{metacall.h}!metacall\_object\_set@{metacall\_object\_set}}
\index{metacall\_object\_set@{metacall\_object\_set}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_object\_set()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+object\+\_\+set (\begin{DoxyParamCaption}\item[{void $\ast$}]{obj,  }\item[{const char $\ast$}]{key,  }\item[{void $\ast$}]{v }\end{DoxyParamCaption})}



Set an attribute to @obj by @key name. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em obj} & Pointer to the object\\
\hline
\mbox{\texttt{ in}}  & {\em key} & Name of the attribute to set\\
\hline
\mbox{\texttt{ in}}  & {\em value} & Value to set\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Non-\/zero integer if an error ocurred 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a7e1d1400dc0a308eff0ad61495aece15}} 
\index{metacall.h@{metacall.h}!metacall\_throwable\_value@{metacall\_throwable\_value}}
\index{metacall\_throwable\_value@{metacall\_throwable\_value}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_throwable\_value()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+throwable\+\_\+value (\begin{DoxyParamCaption}\item[{void $\ast$}]{th }\end{DoxyParamCaption})}



Get the value contained by throwable object @th. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em th} & Pointer to the throwable object\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the value inside of the throwable or NULL in case of error 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ab9d6a8fa4d186f14741ef15015798eb0}} 
\index{metacall.h@{metacall.h}!metacall\_inspect@{metacall\_inspect}}
\index{metacall\_inspect@{metacall\_inspect}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_inspect()}
{\footnotesize\ttfamily METACALL\+\_\+\+API char$\ast$ metacall\+\_\+inspect (\begin{DoxyParamCaption}\item[{size\+\_\+t $\ast$}]{size,  }\item[{void $\ast$}]{allocator }\end{DoxyParamCaption})}



Provide information about all loaded objects. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em size} & Size in bytes of return buffer\\
\hline
\mbox{\texttt{ in}}  & {\em allocator} & Pointer to allocator will allocate the string\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
String containing introspection information 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a640b7fe3b2b8b119abc047f3e7a3e2bf}} 
\index{metacall.h@{metacall.h}!metacall\_inspect\_value@{metacall\_inspect\_value}}
\index{metacall\_inspect\_value@{metacall\_inspect\_value}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_inspect\_value()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+inspect\+\_\+value (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Provide information about all loaded objects as a value. 

\begin{DoxyReturn}{Returns}
Value containing introspection information 
\end{DoxyReturn}
\mbox{\label{metacall_8h_acdcbeeeafdc83e9b69937265a0da53c3}} 
\index{metacall.h@{metacall.h}!metacall\_serialize@{metacall\_serialize}}
\index{metacall\_serialize@{metacall\_serialize}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_serialize()}
{\footnotesize\ttfamily METACALL\+\_\+\+API char$\ast$ metacall\+\_\+serialize (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{v,  }\item[{size\+\_\+t $\ast$}]{size,  }\item[{void $\ast$}]{allocator }\end{DoxyParamCaption})}



Convert the value @v to serialized string. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the serial to be used\\
\hline
\mbox{\texttt{ in}}  & {\em v} & Reference to the value\\
\hline
\mbox{\texttt{ out}}  & {\em size} & Size of new allocated string\\
\hline
\mbox{\texttt{ in}}  & {\em allocator} & Pointer to allocator will allocate the string\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
New allocated string containing stringified value 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a0d45c99a4491e8bbad9d66aa8e719e54}} 
\index{metacall.h@{metacall.h}!metacall\_deserialize@{metacall\_deserialize}}
\index{metacall\_deserialize@{metacall\_deserialize}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_deserialize()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+deserialize (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{const char $\ast$}]{buffer,  }\item[{size\+\_\+t}]{size,  }\item[{void $\ast$}]{allocator }\end{DoxyParamCaption})}



Convert the string @buffer to value. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & Name of the serial to be used\\
\hline
\mbox{\texttt{ in}}  & {\em buffer} & String to be deserialized\\
\hline
\mbox{\texttt{ in}}  & {\em size} & Size of string @buffer\\
\hline
\mbox{\texttt{ in}}  & {\em allocator} & Pointer to allocator will allocate the value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
New allocated value representing the string (must be freed) 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ae1f35c9c5cd2b375e8fb00b9d8c5890c}} 
\index{metacall.h@{metacall.h}!metacall\_clear@{metacall\_clear}}
\index{metacall\_clear@{metacall\_clear}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_clear()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+clear (\begin{DoxyParamCaption}\item[{void $\ast$}]{handle }\end{DoxyParamCaption})}



Clear handle from memory and unload related resources. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em handle} & Reference to the handle to be unloaded\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a57ecb3af9057cf7c9457bab16b0958ac}} 
\index{metacall.h@{metacall.h}!metacall\_plugin\_extension@{metacall\_plugin\_extension}}
\index{metacall\_plugin\_extension@{metacall\_plugin\_extension}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_plugin\_extension()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+plugin\+\_\+extension (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Get the plugin extension handle to be used for loading plugins. 

\begin{DoxyReturn}{Returns}
Pointer to the extension handle, or null if it failed to load 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a101e7feb381df9da2026bd1fb2505161}} 
\index{metacall.h@{metacall.h}!metacall\_plugin\_core@{metacall\_plugin\_core}}
\index{metacall\_plugin\_core@{metacall\_plugin\_core}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_plugin\_core()}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+plugin\+\_\+core (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Get the handle containing all the functionality of the plugins from core. 

\begin{DoxyReturn}{Returns}
Pointer to the core plugin handle, or null if it failed to load 
\end{DoxyReturn}
\mbox{\label{metacall_8h_aa2add9c2e53f0bbd664392ada75cd5b0}} 
\index{metacall.h@{metacall.h}!metacall\_plugin\_path@{metacall\_plugin\_path}}
\index{metacall\_plugin\_path@{metacall\_plugin\_path}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_plugin\_path()}
{\footnotesize\ttfamily METACALL\+\_\+\+API const char$\ast$ metacall\+\_\+plugin\+\_\+path (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Get the plugin extension path to be used for accessing the plugins folder. 

\begin{DoxyReturn}{Returns}
String containing the core plugin path, or null if it failed to load the plugin extension 
\end{DoxyReturn}
\mbox{\label{metacall_8h_aca8745a9f261bc3d37ee9156b991296f}} 
\index{metacall.h@{metacall.h}!metacall\_destroy@{metacall\_destroy}}
\index{metacall\_destroy@{metacall\_destroy}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_destroy()}
{\footnotesize\ttfamily METACALL\+\_\+\+API int metacall\+\_\+destroy (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Destroy Meta\+Call library. 

\begin{DoxyReturn}{Returns}
Zero if success, different from zero otherwise 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a1193b3c37aee3b2f5ed49b1e08784ffd}} 
\index{metacall.h@{metacall.h}!metacall\_version@{metacall\_version}}
\index{metacall\_version@{metacall\_version}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_version()}
{\footnotesize\ttfamily METACALL\+\_\+\+API const struct \textbf{ metacall\+\_\+version\+\_\+type}$\ast$ metacall\+\_\+version (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Provide the module version struct. 

\begin{DoxyReturn}{Returns}
Static struct containing unpacked version 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a3af1b1656bce5952ccd86352bdd76bb0}} 
\index{metacall.h@{metacall.h}!metacall\_version\_hex\_make@{metacall\_version\_hex\_make}}
\index{metacall\_version\_hex\_make@{metacall\_version\_hex\_make}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_version\_hex\_make()}
{\footnotesize\ttfamily METACALL\+\_\+\+API uint32\+\_\+t metacall\+\_\+version\+\_\+hex\+\_\+make (\begin{DoxyParamCaption}\item[{unsigned int}]{major,  }\item[{unsigned int}]{minor,  }\item[{unsigned int}]{patch }\end{DoxyParamCaption})}



Provide the module version hexadecimal value with format 0x\+MMIIPPPP where M is @major, I is @minor and P is @patch. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em major} & Unsigned integer representing major version\\
\hline
\mbox{\texttt{ in}}  & {\em minor} & Unsigned integer representing minor version\\
\hline
\mbox{\texttt{ in}}  & {\em patch} & Unsigned integer representing patch version\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Hexadecimal integer containing packed version 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a81a1feba31ad43cd3dda3d08699e1780}} 
\index{metacall.h@{metacall.h}!metacall\_version\_hex@{metacall\_version\_hex}}
\index{metacall\_version\_hex@{metacall\_version\_hex}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_version\_hex()}
{\footnotesize\ttfamily METACALL\+\_\+\+API uint32\+\_\+t metacall\+\_\+version\+\_\+hex (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Provide the module version hexadecimal value with format 0x\+MMIIPPPP where M is major, I is minor and P is patch. 

\begin{DoxyReturn}{Returns}
Hexadecimal integer containing packed version 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a8c0fd2d5fca3f94b8d52e2fa7ee79788}} 
\index{metacall.h@{metacall.h}!metacall\_version\_str@{metacall\_version\_str}}
\index{metacall\_version\_str@{metacall\_version\_str}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_version\_str()}
{\footnotesize\ttfamily METACALL\+\_\+\+API const char$\ast$ metacall\+\_\+version\+\_\+str (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Provide the module version string. 

\begin{DoxyReturn}{Returns}
Static string containing module version 
\end{DoxyReturn}
\mbox{\label{metacall_8h_ab7beb4c0175a8e98b445bb0bc2218dba}} 
\index{metacall.h@{metacall.h}!metacall\_version\_revision@{metacall\_version\_revision}}
\index{metacall\_version\_revision@{metacall\_version\_revision}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_version\_revision()}
{\footnotesize\ttfamily METACALL\+\_\+\+API const char$\ast$ metacall\+\_\+version\+\_\+revision (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Provide the module version revision string. 

\begin{DoxyReturn}{Returns}
Static string containing module version revision 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a8c2bfc0f3461385a84c61e4142d3bc47}} 
\index{metacall.h@{metacall.h}!metacall\_version\_name@{metacall\_version\_name}}
\index{metacall\_version\_name@{metacall\_version\_name}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_version\_name()}
{\footnotesize\ttfamily METACALL\+\_\+\+API const char$\ast$ metacall\+\_\+version\+\_\+name (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Provide the module version name. 

\begin{DoxyReturn}{Returns}
Static string containing module version name 
\end{DoxyReturn}
\mbox{\label{metacall_8h_a47d8e1e26509c0c775ba0ecbd08f9288}} 
\index{metacall.h@{metacall.h}!metacall\_print\_info@{metacall\_print\_info}}
\index{metacall\_print\_info@{metacall\_print\_info}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_print\_info()}
{\footnotesize\ttfamily METACALL\+\_\+\+API const char$\ast$ metacall\+\_\+print\+\_\+info (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Provide the module information. 

\begin{DoxyReturn}{Returns}
Static string containing module information 
\end{DoxyReturn}


\doxysubsection{Variable Documentation}
\mbox{\label{metacall_8h_ad50602b5115964e06b18483807ba1e11}} 
\index{metacall.h@{metacall.h}!metacall\_null\_args@{metacall\_null\_args}}
\index{metacall\_null\_args@{metacall\_null\_args}!metacall.h@{metacall.h}}
\doxysubsubsection{metacall\_null\_args}
{\footnotesize\ttfamily METACALL\+\_\+\+API void$\ast$ metacall\+\_\+null\+\_\+args[1]\hspace{0.3cm}{\ttfamily [extern]}}

