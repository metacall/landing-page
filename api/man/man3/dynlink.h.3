.TH "dynlink.h" 3 "Thu Feb 8 2024" "Version 0.7.7.251ee5582288" "MetaCall" \" -*- nroff -*-
.ad l
.nh
.SH NAME
dynlink.h
.SH SYNOPSIS
.br
.PP
\fC#include <dynlink/dynlink_api\&.h>\fP
.br
\fC#include <dynlink/dynlink_type\&.h>\fP
.br
\fC#include <dynlink/dynlink_flags\&.h>\fP
.br
\fC#include <dynlink/dynlink_interface\&.h>\fP
.br
\fC#include <dynlink/dynlink_symbol\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "DYNLINK_API const char * \fBdynlink_extension\fP (void)"
.br
.ti -1c
.RI "DYNLINK_API \fBdynlink\fP \fBdynlink_load\fP (\fBdynlink_path\fP path, \fBdynlink_name\fP name, \fBdynlink_flags\fP flags)"
.br
.ti -1c
.RI "DYNLINK_API \fBdynlink_name\fP \fBdynlink_get_name\fP (\fBdynlink\fP handle)"
.br
.ti -1c
.RI "DYNLINK_API \fBdynlink_name\fP \fBdynlink_get_name_impl\fP (\fBdynlink\fP handle)"
.br
.ti -1c
.RI "DYNLINK_API \fBdynlink_flags\fP \fBdynlink_get_flags\fP (\fBdynlink\fP handle)"
.br
.ti -1c
.RI "DYNLINK_API int \fBdynlink_symbol\fP (\fBdynlink\fP handle, \fBdynlink_symbol_name\fP symbol_name, \fBdynlink_symbol_addr\fP *symbol_address)"
.br
.ti -1c
.RI "DYNLINK_API void \fBdynlink_unload\fP (\fBdynlink\fP handle)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br
Get the path to a library loaded in the process itself by
.PP
\fBParameters\fP
.RS 4
\fIname\fP Name of the library that will be searched for the path (without platform dependant prefix, suffix or extension)
.br
\fIpath\fP The path found (if any) with that library name
.br
\fIlength\fP The length of the path found (if any)
.RE
.PP
\fBReturns\fP
.RS 4
Returns zero if it could find the path, different from zero if not found 
.RE
.PP

.PP
.in +1c
.in +1c
.ti -1c
.RI "DYNLINK_API int \fBdynlink_library_path\fP (\fBdynlink_name\fP name, \fBdynlink_library_path_str\fP path, size_t *length)"
.br
.in -1c
.in -1c
.PP
.RI "\fBas a base for it\fP"
.br
Retrieve the library platform standard name by using
.PP
\fBParameters\fP
.RS 4
\fIname\fP Name of the library that will be used for generating the platform dependant library name (i\&.e example)
.br
\fIresult\fP The resulting library name that will be generated (i\&.e libexample\&.so in Linux, or example\&.dll in Windows) 
.RE
.PP

.PP
.in +1c
.in +1c
.ti -1c
.RI "DYNLINK_API void \fBdynlink_platform_name\fP (\fBdynlink_name\fP name, \fBdynlink_name_impl\fP result)"
.br
.ti -1c
.RI "DYNLINK_API const char * \fBdynlink_print_info\fP (void)"
.br
.in -1c
.in -1c
.SH "Function Documentation"
.PP 
.SS "DYNLINK_API const char* dynlink_extension (void)"

.PP
Get the library extension for specified platform\&. 
.PP
\fBReturns\fP
.RS 4
A constant string pointer to the platform extension 
.RE
.PP

.SS "DYNLINK_API \fBdynlink\fP dynlink_load (\fBdynlink_path\fP path, \fBdynlink_name\fP name, \fBdynlink_flags\fP flags)"

.PP
Load a dynamically linked shared object\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP Path where is located the shared object
.br
\fIname\fP Name identifier of the shared object
.br
\fIflags\fP Dynamic linking flags
.RE
.PP
\fBReturns\fP
.RS 4
A handle to the dynamically linked shared object 
.RE
.PP

.SS "DYNLINK_API \fBdynlink_name\fP dynlink_get_name (\fBdynlink\fP handle)"

.PP
Retreive the name of the dynamically linked shared object\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP Handle of dynamically linked shared object
.RE
.PP
\fBReturns\fP
.RS 4
Reference to the name of the dynamically linked shared object 
.RE
.PP

.SS "DYNLINK_API \fBdynlink_name\fP dynlink_get_name_impl (\fBdynlink\fP handle)"

.PP
Retreive the file name of the dynamically linked shared object handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP Handle of dynamically linked shared object
.RE
.PP
\fBReturns\fP
.RS 4
Reference to the file name of the dynamically linked shared object 
.RE
.PP

.SS "DYNLINK_API \fBdynlink_flags\fP dynlink_get_flags (\fBdynlink\fP handle)"

.PP
Retreive the linking flags of the dynamically linked shared object\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP Handle of dynamically linked shared object
.RE
.PP
\fBReturns\fP
.RS 4
Linking flags of dynamically linked shared object 
.RE
.PP

.SS "DYNLINK_API int dynlink_symbol (\fBdynlink\fP handle, \fBdynlink_symbol_name\fP symbol_name, \fBdynlink_symbol_addr\fP * symbol_address)"

.PP
Get a symbol address of dynamically linked shared object by name\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP Handle of dynamically linked shared object
.br
\fIsymbol_name\fP Name of the of dynamically linked shared object symbol
.br
\fIsymbol_address\fP Pointer to the address of the of dynamically linked shared object symbol
.RE
.PP
\fBReturns\fP
.RS 4
Returns zero on correct dynamic linking, distinct from zero otherwise 
.RE
.PP

.SS "DYNLINK_API void dynlink_unload (\fBdynlink\fP handle)"

.PP
Unloads a dynamically linked shared object by its handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP Handle of dynamically linked shared object 
.RE
.PP

.SS "DYNLINK_API int dynlink_library_path (\fBdynlink_name\fP name, \fBdynlink_library_path_str\fP path, size_t * length)"

.SS "DYNLINK_API void dynlink_platform_name (\fBdynlink_name\fP name, \fBdynlink_name_impl\fP result)"

.SS "DYNLINK_API const char* dynlink_print_info (void)"

.PP
Provide the module information\&. 
.PP
\fBReturns\fP
.RS 4
Static string containing module information 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for MetaCall from the source code\&.
