<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MetaCall: metacall.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MetaCall
   &#160;<span id="projectnumber">0.7.7.251ee5582288</span>
   </div>
   <div id="projectbrief">A library for providing inter-language foreign function interface calls</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('metacall_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">metacall.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;metacall/metacall_api.h&gt;</code><br />
<code>#include &lt;<a class="el" href="metacall__allocator_8h_source.html">metacall/metacall_allocator.h</a>&gt;</code><br />
<code>#include &lt;metacall/metacall_def.h&gt;</code><br />
<code>#include &lt;<a class="el" href="metacall__error_8h_source.html">metacall/metacall_error.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="metacall__log_8h_source.html">metacall/metacall_log.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="metacall__value_8h_source.html">metacall/metacall_value.h</a>&gt;</code><br />
<code>#include &lt;metacall/metacall_version.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for metacall.h:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="metacall_8h__incl.png" border="0" usemap="#ametacall_8h" alt=""/></div>
<map name="ametacall_8h" id="ametacall_8h">
<area shape="rect" title=" " alt="" coords="581,5,657,31"/>
<area shape="rect" title=" " alt="" coords="273,152,421,177"/>
<area shape="rect" href="metacall__allocator_8h.html" title=" " alt="" coords="259,79,435,104"/>
<area shape="rect" title=" " alt="" coords="735,152,794,177"/>
<area shape="rect" title=" " alt="" coords="74,152,134,177"/>
<area shape="rect" title=" " alt="" coords="459,79,606,104"/>
<area shape="rect" href="metacall__error_8h.html" title=" " alt="" coords="630,79,784,104"/>
<area shape="rect" href="metacall__log_8h.html" title=" " alt="" coords="859,79,1006,104"/>
<area shape="rect" title=" " alt="" coords="997,152,1062,177"/>
<area shape="rect" href="metacall__value_8h.html" title=" " alt="" coords="25,79,184,104"/>
<area shape="rect" title=" " alt="" coords="1080,79,1248,104"/>
<area shape="rect" title=" " alt="" coords="904,152,960,177"/>
</map>
</div>
</div><div class="textblock"><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> This graph shows which files directly or indirectly include this file:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="metacall_8h__dep__incl.png" border="0" usemap="#ametacall_8hdep" alt=""/></div>
<map name="ametacall_8hdep" id="ametacall_8hdep">
<area shape="rect" title=" " alt="" coords="31,5,107,31"/>
<area shape="rect" href="plugin__interface_8hpp.html" title=" " alt="" coords="5,79,133,104"/>
</map>
</div>
</div>
<p><a href="metacall_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmetacall__initialize__configuration__type.html">metacall_initialize_configuration_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmetacall__await__callbacks.html">metacall_await_callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmetacall__version__type.html">metacall_version_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9c8f9f1a02aa8b7f11203f473ad45a0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a9c8f9f1a02aa8b7f11203f473ad45a0c">METACALL_FLAGS_FORK_SAFE</a>&#160;&#160;&#160;0x01 &lt;&lt; 0x00</td></tr>
<tr class="separator:a9c8f9f1a02aa8b7f11203f473ad45a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa9b6fcb756e3ac95f638f4a42bb8f5d4"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#aa9b6fcb756e3ac95f638f4a42bb8f5d4">metacall_await_callback</a>) (void *, void *)</td></tr>
<tr class="separator:aa9b6fcb756e3ac95f638f4a42bb8f5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adf5d6e87973ec71e38292324d0fd8048"><td class="memItemLeft" align="right" valign="top">METACALL_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#adf5d6e87973ec71e38292324d0fd8048">metacall_serial</a> (void)</td></tr>
<tr class="separator:adf5d6e87973ec71e38292324d0fd8048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7359cf8608ee329433d129f74621f6b7"><td class="memItemLeft" align="right" valign="top">METACALL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a7359cf8608ee329433d129f74621f6b7">metacall_log_null</a> (void)</td></tr>
<tr class="separator:a7359cf8608ee329433d129f74621f6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ae3eea97bc40256b292aea7f36b61c"><td class="memItemLeft" align="right" valign="top">METACALL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a59ae3eea97bc40256b292aea7f36b61c">metacall_flags</a> (int flags)</td></tr>
<tr class="separator:a59ae3eea97bc40256b292aea7f36b61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef066c5638c4e049288d98911e1a799f"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#aef066c5638c4e049288d98911e1a799f">metacall_initialize</a> (void)</td></tr>
<tr class="separator:aef066c5638c4e049288d98911e1a799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c70099ab9944bc953ff0998fa92f97e"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a9c70099ab9944bc953ff0998fa92f97e">metacall_initialize_ex</a> (struct <a class="el" href="structmetacall__initialize__configuration__type.html">metacall_initialize_configuration_type</a> initialize_config[])</td></tr>
<tr class="separator:a9c70099ab9944bc953ff0998fa92f97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2759ffd9206401b14fb75d53bf35987"><td class="memItemLeft" align="right" valign="top">METACALL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ab2759ffd9206401b14fb75d53bf35987">metacall_initialize_args</a> (int argc, char *argv[])</td></tr>
<tr class="separator:ab2759ffd9206401b14fb75d53bf35987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881a9d10167e78461635f285a788816c"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a881a9d10167e78461635f285a788816c">metacall_argc</a> (void)</td></tr>
<tr class="separator:a881a9d10167e78461635f285a788816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0bd7df095d9a4db05204f04fa657a3"><td class="memItemLeft" align="right" valign="top">METACALL_API char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a9c0bd7df095d9a4db05204f04fa657a3">metacall_argv</a> (void)</td></tr>
<tr class="separator:a9c0bd7df095d9a4db05204f04fa657a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9924c55b771ae7f80d6b153ad412d3"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a6e9924c55b771ae7f80d6b153ad412d3">metacall_is_initialized</a> (const char *tag)</td></tr>
<tr class="separator:a6e9924c55b771ae7f80d6b153ad412d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af773258f002ae5ea241b945ae4315d49"><td class="memItemLeft" align="right" valign="top">METACALL_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#af773258f002ae5ea241b945ae4315d49">metacall_args_size</a> (void)</td></tr>
<tr class="separator:af773258f002ae5ea241b945ae4315d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bbd56502b7bdd53fdbe42b46aceb16"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a14bbd56502b7bdd53fdbe42b46aceb16">metacall_execution_path</a> (const char *tag, const char *path)</td></tr>
<tr class="separator:a14bbd56502b7bdd53fdbe42b46aceb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fd858391d840206fe14725c2b695e2"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ab6fd858391d840206fe14725c2b695e2">metacall_execution_path_s</a> (const char *tag, size_t tag_length, const char *path, size_t path_length)</td></tr>
<tr class="separator:ab6fd858391d840206fe14725c2b695e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf8160c6bdd7c5c2614b40be31ce887"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a4cf8160c6bdd7c5c2614b40be31ce887">metacall_load_from_file</a> (const char *tag, const char *paths[], size_t size, void **handle)</td></tr>
<tr class="separator:a4cf8160c6bdd7c5c2614b40be31ce887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa202ac4aeb04129ab475099af696b7b8"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#aa202ac4aeb04129ab475099af696b7b8">metacall_load_from_memory</a> (const char *tag, const char *buffer, size_t size, void **handle)</td></tr>
<tr class="separator:aa202ac4aeb04129ab475099af696b7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62d509141fe85874f1865f61b4075af"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ae62d509141fe85874f1865f61b4075af">metacall_load_from_package</a> (const char *tag, const char *path, void **handle)</td></tr>
<tr class="separator:ae62d509141fe85874f1865f61b4075af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a0cad16a66aaaab0f2e523ee390be3"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a00a0cad16a66aaaab0f2e523ee390be3">metacall_load_from_configuration</a> (const char *path, void **handle, void *allocator)</td></tr>
<tr class="separator:a00a0cad16a66aaaab0f2e523ee390be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2c0d0a24b9f6e4908bbac36d98954b"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#afc2c0d0a24b9f6e4908bbac36d98954b">metacallv</a> (const char *name, void *args[])</td></tr>
<tr class="separator:afc2c0d0a24b9f6e4908bbac36d98954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad934b33c0c04c424d7080735d86a240c"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ad934b33c0c04c424d7080735d86a240c">metacallv_s</a> (const char *name, void *args[], size_t size)</td></tr>
<tr class="separator:ad934b33c0c04c424d7080735d86a240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa8b58b55e753ebcb2c6ca7221261fe"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#abaa8b58b55e753ebcb2c6ca7221261fe">metacallhv</a> (void *handle, const char *name, void *args[])</td></tr>
<tr class="separator:abaa8b58b55e753ebcb2c6ca7221261fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0973f34ae8081817abbcc84e54b09fcc"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a0973f34ae8081817abbcc84e54b09fcc">metacallhv_s</a> (void *handle, const char *name, void *args[], size_t size)</td></tr>
<tr class="separator:a0973f34ae8081817abbcc84e54b09fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927b07b0d76019322c9a84a768333be7"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a927b07b0d76019322c9a84a768333be7">metacall</a> (const char *name,...)</td></tr>
<tr class="separator:a927b07b0d76019322c9a84a768333be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6052ad320dd2bb83d6c39d7bac3a1e"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a3d6052ad320dd2bb83d6c39d7bac3a1e">metacallt</a> (const char *name, const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> ids[],...)</td></tr>
<tr class="separator:a3d6052ad320dd2bb83d6c39d7bac3a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e003693bcf043424e5bd77255ef629"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a93e003693bcf043424e5bd77255ef629">metacallt_s</a> (const char *name, const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> ids[], size_t size,...)</td></tr>
<tr class="separator:a93e003693bcf043424e5bd77255ef629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020d72d3ec5fac1ef707e57e356ef0ea"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a020d72d3ec5fac1ef707e57e356ef0ea">metacallht_s</a> (void *handle, const char *name, const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> ids[], size_t size,...)</td></tr>
<tr class="separator:a020d72d3ec5fac1ef707e57e356ef0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get the function by</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function reference, null if the function does not exist </dd></dl>
</div></td></tr>
<tr class="memitem:a137dbf351f620ac5c1daebf1564f099b"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a137dbf351f620ac5c1daebf1564f099b">metacall_function</a> (const char *name)</td></tr>
<tr class="separator:a137dbf351f620ac5c1daebf1564f099b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">from @handle</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get the function by</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to the handle returned by metacall_load_from_{file, memory, package}</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function reference, null if the function does not exist </dd></dl>
</div></td></tr>
<tr class="memitem:a0733570d83d6daf0e421e3e414547566"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a0733570d83d6daf0e421e3e414547566">metacall_handle_function</a> (void *handle, const char *name)</td></tr>
<tr class="separator:a0733570d83d6daf0e421e3e414547566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ff10520ec45fc6dc56e6b731f7cd98"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a26ff10520ec45fc6dc56e6b731f7cd98">metacall_function_parameter_type</a> (void *func, size_t parameter, enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> *id)</td></tr>
<tr class="separator:a26ff10520ec45fc6dc56e6b731f7cd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391f6f382c453d8903889a910f59bf4c"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a391f6f382c453d8903889a910f59bf4c">metacall_function_return_type</a> (void *func, enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> *id)</td></tr>
<tr class="separator:a391f6f382c453d8903889a910f59bf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41ffa4531b7819e7f0d1c580ef508c5"><td class="memItemLeft" align="right" valign="top">METACALL_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ae41ffa4531b7819e7f0d1c580ef508c5">metacall_function_size</a> (void *func)</td></tr>
<tr class="separator:ae41ffa4531b7819e7f0d1c580ef508c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f7b6d24d91f6aa2b1a1bf773a2be3b"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a42f7b6d24d91f6aa2b1a1bf773a2be3b">metacall_function_async</a> (void *func)</td></tr>
<tr class="separator:a42f7b6d24d91f6aa2b1a1bf773a2be3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get the handle by</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Extension of the script</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle reference, null if the function does not exist </dd></dl>
</div></td></tr>
<tr class="memitem:a579d699c4407cc27e94d216303f152aa"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a579d699c4407cc27e94d216303f152aa">metacall_handle</a> (const char *tag, const char *name)</td></tr>
<tr class="separator:a579d699c4407cc27e94d216303f152aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593872223a3cbbf9856ce9d9dc8ba2da"><td class="memItemLeft" align="right" valign="top">METACALL_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a593872223a3cbbf9856ce9d9dc8ba2da">metacall_handle_id</a> (void *handle)</td></tr>
<tr class="separator:a593872223a3cbbf9856ce9d9dc8ba2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69cc4988cf490c58d1c5d72ce7a3f95"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ad69cc4988cf490c58d1c5d72ce7a3f95">metacall_handle_export</a> (void *handle)</td></tr>
<tr class="separator:ad69cc4988cf490c58d1c5d72ce7a3f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7029ce54bb2a8fb4516415e42d6d986b"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a7029ce54bb2a8fb4516415e42d6d986b">metacallfv</a> (void *func, void *args[])</td></tr>
<tr class="separator:a7029ce54bb2a8fb4516415e42d6d986b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaf2d96cbe7e899e9f5450be7d7d1c4"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#afcaf2d96cbe7e899e9f5450be7d7d1c4">metacallfv_s</a> (void *func, void *args[], size_t size)</td></tr>
<tr class="separator:afcaf2d96cbe7e899e9f5450be7d7d1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae523e9a658d5ea11bde72660df84df95"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ae523e9a658d5ea11bde72660df84df95">metacallf</a> (void *func,...)</td></tr>
<tr class="separator:ae523e9a658d5ea11bde72660df84df95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5e0d836963404a27918bfade98cad"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a6de5e0d836963404a27918bfade98cad">metacallfs</a> (void *func, const char *buffer, size_t size, void *allocator)</td></tr>
<tr class="separator:a6de5e0d836963404a27918bfade98cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ecf16f1985cecee777d9e84c70d79a"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ac1ecf16f1985cecee777d9e84c70d79a">metacallfmv</a> (void *func, void *keys[], void *values[])</td></tr>
<tr class="separator:ac1ecf16f1985cecee777d9e84c70d79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae381876c35f6b194c96c19a9b808e313"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ae381876c35f6b194c96c19a9b808e313">metacallfms</a> (void *func, const char *buffer, size_t size, void *allocator)</td></tr>
<tr class="separator:ae381876c35f6b194c96c19a9b808e313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">and arguments @va_args</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Register a function by name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function (if it is NULL, function is not registered into host scope)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invoke</td><td>Pointer to function invoke interface (argc, argv, data)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">func</td><td>Will set the pointer to the function if the parameter is not null</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">return_type</td><td>Type of return value</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of function arguments</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">va_args</td><td>Varidic function parameter types</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>
</div></td></tr>
<tr class="memitem:a810ca74b8efef842df8ea7baf2b87e67"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a810ca74b8efef842df8ea7baf2b87e67">metacall_register</a> (const char *name, void *(*invoke)(size_t, void *[], void *), void **func, enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> return_type, size_t size,...)</td></tr>
<tr class="separator:a810ca74b8efef842df8ea7baf2b87e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">and arguments @types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Register a function by name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loader</td><td>Opaque pointer to the loader in which you want to register the function (this allows to register the function into a different loader than the host)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Opaque pointer to the context in which you want to register the function (if it is NULL, it will be defined on the global scope of the loader)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function (if it is NULL, function is not registered into host scope)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">invoke</td><td>Pointer to function invoke interface (argc, argv, data)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">return_type</td><td>Type of return value</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of function arguments</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">types</td><td>List of parameter types</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>
</div></td></tr>
<tr class="memitem:ae0f575287847cd57f5a549b2b211db1d"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ae0f575287847cd57f5a549b2b211db1d">metacall_registerv</a> (const char *name, void *(*invoke)(size_t, void *[], void *), void **func, enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> return_type, size_t size, enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> types[])</td></tr>
<tr class="separator:ae0f575287847cd57f5a549b2b211db1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4e32dfcccfefd3fec11b80f7edd10a"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#afc4e32dfcccfefd3fec11b80f7edd10a">metacall_register_loaderv</a> (void *<a class="el" href="loader_8h.html#ae460ed5a03319c8ef3c08f3cd7ecc9d5">loader</a>, void *<a class="el" href="reflect__context_8h.html#ab01e2b1d8e268430d5c2d3d1d870251b">context</a>, const char *name, void *(*invoke)(size_t, void *[], void *), enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> return_type, size_t size, enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> types[])</td></tr>
<tr class="separator:afc4e32dfcccfefd3fec11b80f7edd10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ef2927638d958c6e76555fc49a765b"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a52ef2927638d958c6e76555fc49a765b">metacall_await</a> (const char *name, void *args[], void *(*resolve_callback)(void *, void *), void *(*reject_callback)(void *, void *), void *data)</td></tr>
<tr class="separator:a52ef2927638d958c6e76555fc49a765b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f24de215645b2728c80e20685cb5525"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a5f24de215645b2728c80e20685cb5525">metacall_await_future</a> (void *f, void *(*resolve_callback)(void *, void *), void *(*reject_callback)(void *, void *), void *data)</td></tr>
<tr class="separator:a5f24de215645b2728c80e20685cb5525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698f9b1a031af836302d2634e3194f75"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a698f9b1a031af836302d2634e3194f75">metacall_await_s</a> (const char *name, void *args[], size_t size, void *(*resolve_callback)(void *, void *), void *(*reject_callback)(void *, void *), void *data)</td></tr>
<tr class="separator:a698f9b1a031af836302d2634e3194f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aae2677499d7bc7992840e90d754d83"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a4aae2677499d7bc7992840e90d754d83">metacallfv_await</a> (void *func, void *args[], void *(*resolve_callback)(void *, void *), void *(*reject_callback)(void *, void *), void *data)</td></tr>
<tr class="separator:a4aae2677499d7bc7992840e90d754d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5ead1f1aa559e58a65f69ae51972cb"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a9c5ead1f1aa559e58a65f69ae51972cb">metacallfv_await_s</a> (void *func, void *args[], size_t size, void *(*resolve_callback)(void *, void *), void *(*reject_callback)(void *, void *), void *data)</td></tr>
<tr class="separator:a9c5ead1f1aa559e58a65f69ae51972cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe71978aefb3bb4d664ddf54b5ab81b7"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#afe71978aefb3bb4d664ddf54b5ab81b7">metacallfv_await_struct_s</a> (void *func, void *args[], size_t size, <a class="el" href="structmetacall__await__callbacks.html">metacall_await_callbacks</a> cb, void *data)</td></tr>
<tr class="separator:afe71978aefb3bb4d664ddf54b5ab81b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806b1dda95f596de33a9527123fed8e4"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a806b1dda95f596de33a9527123fed8e4">metacallfmv_await</a> (void *func, void *keys[], void *values[], void *(*resolve_callback)(void *, void *), void *(*reject_callback)(void *, void *), void *data)</td></tr>
<tr class="separator:a806b1dda95f596de33a9527123fed8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8d0fa0f6b7c3607bd92524a11f3c5c"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a4c8d0fa0f6b7c3607bd92524a11f3c5c">metacallfmv_await_s</a> (void *func, void *keys[], void *values[], size_t size, void *(*resolve_callback)(void *, void *), void *(*reject_callback)(void *, void *), void *data)</td></tr>
<tr class="separator:a4c8d0fa0f6b7c3607bd92524a11f3c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd2e38b4966b41bc2473c172d52147d"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#addd2e38b4966b41bc2473c172d52147d">metacallfs_await</a> (void *func, const char *buffer, size_t size, void *allocator, void *(*resolve_callback)(void *, void *), void *(*reject_callback)(void *, void *), void *data)</td></tr>
<tr class="separator:addd2e38b4966b41bc2473c172d52147d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6111e7af53fb3dcf04018aa7a06b01e3"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a6111e7af53fb3dcf04018aa7a06b01e3">metacallfms_await</a> (void *func, const char *buffer, size_t size, void *allocator, void *(*resolve_callback)(void *, void *), void *(*reject_callback)(void *, void *), void *data)</td></tr>
<tr class="separator:a6111e7af53fb3dcf04018aa7a06b01e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get the class by</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the class</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Class reference, null if the class does not exist </dd></dl>
</div></td></tr>
<tr class="memitem:a62422ba9010c261547585dc014f5f71f"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a62422ba9010c261547585dc014f5f71f">metacall_class</a> (const char *name)</td></tr>
<tr class="separator:a62422ba9010c261547585dc014f5f71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f50d305c683edfbeec022d41d8b749"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a97f50d305c683edfbeec022d41d8b749">metacallv_class</a> (void *cls, const char *name, void *args[], size_t size)</td></tr>
<tr class="separator:a97f50d305c683edfbeec022d41d8b749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e15e8ca121a9b0c5b1f22f760d7137"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ac0e15e8ca121a9b0c5b1f22f760d7137">metacallt_class</a> (void *cls, const char *name, const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> ret, void *args[], size_t size)</td></tr>
<tr class="separator:ac0e15e8ca121a9b0c5b1f22f760d7137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee922f6a17e2d304c8074342779205c1"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#aee922f6a17e2d304c8074342779205c1">metacall_class_new</a> (void *cls, const char *name, void *args[], size_t size)</td></tr>
<tr class="separator:aee922f6a17e2d304c8074342779205c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70337e2f826dab637d640337404831cf"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a70337e2f826dab637d640337404831cf">metacall_class_static_get</a> (void *cls, const char *key)</td></tr>
<tr class="separator:a70337e2f826dab637d640337404831cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69032d3eec3834b36d907141f32332a"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ad69032d3eec3834b36d907141f32332a">metacall_class_static_set</a> (void *cls, const char *key, void *v)</td></tr>
<tr class="separator:ad69032d3eec3834b36d907141f32332a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b346165cc3e9d4c958bf92c65f71ef5"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a1b346165cc3e9d4c958bf92c65f71ef5">metacallv_object</a> (void *obj, const char *name, void *args[], size_t size)</td></tr>
<tr class="separator:a1b346165cc3e9d4c958bf92c65f71ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1391d4d2e8f9dc919ecb6ce5ac00916f"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a1391d4d2e8f9dc919ecb6ce5ac00916f">metacallt_object</a> (void *obj, const char *name, const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> ret, void *args[], size_t size)</td></tr>
<tr class="separator:a1391d4d2e8f9dc919ecb6ce5ac00916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf765af19df6abca9ef981ed56db6b92"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#abf765af19df6abca9ef981ed56db6b92">metacall_object_get</a> (void *obj, const char *key)</td></tr>
<tr class="separator:abf765af19df6abca9ef981ed56db6b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567cbdd3c398e4bcfab8e07ff76de06b"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a567cbdd3c398e4bcfab8e07ff76de06b">metacall_object_set</a> (void *obj, const char *key, void *v)</td></tr>
<tr class="separator:a567cbdd3c398e4bcfab8e07ff76de06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1d1400dc0a308eff0ad61495aece15"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a7e1d1400dc0a308eff0ad61495aece15">metacall_throwable_value</a> (void *th)</td></tr>
<tr class="separator:a7e1d1400dc0a308eff0ad61495aece15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d6a8fa4d186f14741ef15015798eb0"><td class="memItemLeft" align="right" valign="top">METACALL_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ab9d6a8fa4d186f14741ef15015798eb0">metacall_inspect</a> (size_t *size, void *allocator)</td></tr>
<tr class="separator:ab9d6a8fa4d186f14741ef15015798eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640b7fe3b2b8b119abc047f3e7a3e2bf"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a640b7fe3b2b8b119abc047f3e7a3e2bf">metacall_inspect_value</a> (void)</td></tr>
<tr class="separator:a640b7fe3b2b8b119abc047f3e7a3e2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcbeeeafdc83e9b69937265a0da53c3"><td class="memItemLeft" align="right" valign="top">METACALL_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#acdcbeeeafdc83e9b69937265a0da53c3">metacall_serialize</a> (const char *name, void *v, size_t *size, void *allocator)</td></tr>
<tr class="separator:acdcbeeeafdc83e9b69937265a0da53c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d45c99a4491e8bbad9d66aa8e719e54"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a0d45c99a4491e8bbad9d66aa8e719e54">metacall_deserialize</a> (const char *name, const char *buffer, size_t size, void *allocator)</td></tr>
<tr class="separator:a0d45c99a4491e8bbad9d66aa8e719e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f35c9c5cd2b375e8fb00b9d8c5890c"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ae1f35c9c5cd2b375e8fb00b9d8c5890c">metacall_clear</a> (void *handle)</td></tr>
<tr class="separator:ae1f35c9c5cd2b375e8fb00b9d8c5890c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ecb3af9057cf7c9457bab16b0958ac"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a57ecb3af9057cf7c9457bab16b0958ac">metacall_plugin_extension</a> (void)</td></tr>
<tr class="separator:a57ecb3af9057cf7c9457bab16b0958ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2add9c2e53f0bbd664392ada75cd5b0"><td class="memItemLeft" align="right" valign="top">METACALL_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#aa2add9c2e53f0bbd664392ada75cd5b0">metacall_plugin_path</a> (void)</td></tr>
<tr class="separator:aa2add9c2e53f0bbd664392ada75cd5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8745a9f261bc3d37ee9156b991296f"><td class="memItemLeft" align="right" valign="top">METACALL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#aca8745a9f261bc3d37ee9156b991296f">metacall_destroy</a> (void)</td></tr>
<tr class="separator:aca8745a9f261bc3d37ee9156b991296f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1193b3c37aee3b2f5ed49b1e08784ffd"><td class="memItemLeft" align="right" valign="top">METACALL_API const struct <a class="el" href="structmetacall__version__type.html">metacall_version_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a1193b3c37aee3b2f5ed49b1e08784ffd">metacall_version</a> (void)</td></tr>
<tr class="separator:a1193b3c37aee3b2f5ed49b1e08784ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1b1656bce5952ccd86352bdd76bb0"><td class="memItemLeft" align="right" valign="top">METACALL_API uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a3af1b1656bce5952ccd86352bdd76bb0">metacall_version_hex_make</a> (unsigned int major, unsigned int minor, unsigned int patch)</td></tr>
<tr class="separator:a3af1b1656bce5952ccd86352bdd76bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a1feba31ad43cd3dda3d08699e1780"><td class="memItemLeft" align="right" valign="top">METACALL_API uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a81a1feba31ad43cd3dda3d08699e1780">metacall_version_hex</a> (void)</td></tr>
<tr class="separator:a81a1feba31ad43cd3dda3d08699e1780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0fd2d5fca3f94b8d52e2fa7ee79788"><td class="memItemLeft" align="right" valign="top">METACALL_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a8c0fd2d5fca3f94b8d52e2fa7ee79788">metacall_version_str</a> (void)</td></tr>
<tr class="separator:a8c0fd2d5fca3f94b8d52e2fa7ee79788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7beb4c0175a8e98b445bb0bc2218dba"><td class="memItemLeft" align="right" valign="top">METACALL_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ab7beb4c0175a8e98b445bb0bc2218dba">metacall_version_revision</a> (void)</td></tr>
<tr class="separator:ab7beb4c0175a8e98b445bb0bc2218dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2bfc0f3461385a84c61e4142d3bc47"><td class="memItemLeft" align="right" valign="top">METACALL_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a8c2bfc0f3461385a84c61e4142d3bc47">metacall_version_name</a> (void)</td></tr>
<tr class="separator:a8c2bfc0f3461385a84c61e4142d3bc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d8e1e26509c0c775ba0ecbd08f9288"><td class="memItemLeft" align="right" valign="top">METACALL_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#a47d8e1e26509c0c775ba0ecbd08f9288">metacall_print_info</a> (void)</td></tr>
<tr class="separator:a47d8e1e26509c0c775ba0ecbd08f9288"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad50602b5115964e06b18483807ba1e11"><td class="memItemLeft" align="right" valign="top">METACALL_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="metacall_8h.html#ad50602b5115964e06b18483807ba1e11">metacall_null_args</a> [1]</td></tr>
<tr class="separator:ad50602b5115964e06b18483807ba1e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9c8f9f1a02aa8b7f11203f473ad45a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8f9f1a02aa8b7f11203f473ad45a0c">&#9670;&nbsp;</a></span>METACALL_FLAGS_FORK_SAFE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define METACALL_FLAGS_FORK_SAFE&#160;&#160;&#160;0x01 &lt;&lt; 0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa9b6fcb756e3ac95f638f4a42bb8f5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b6fcb756e3ac95f638f4a42bb8f5d4">&#9670;&nbsp;</a></span>metacall_await_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* metacall_await_callback) (void *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adf5d6e87973ec71e38292324d0fd8048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5d6e87973ec71e38292324d0fd8048">&#9670;&nbsp;</a></span>metacall_serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API const char* metacall_serial </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns default serializer used by MetaCall. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of the serializer to be used with serialization methods </dd></dl>

</div>
</div>
<a id="a7359cf8608ee329433d129f74621f6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7359cf8608ee329433d129f74621f6b7">&#9670;&nbsp;</a></span>metacall_log_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void metacall_log_null </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables MetaCall logs, must be called before @metacall_initialize. </p>
<p>When initializing MetaCall, it initializes a default logs to stdout if none was defined. If you want to benchmark or simply disable this default logs, you can call to this function before @metacall_initialize. </p>

</div>
</div>
<a id="a59ae3eea97bc40256b292aea7f36b61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ae3eea97bc40256b292aea7f36b61c">&#9670;&nbsp;</a></span>metacall_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void metacall_flags </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be set in MetaCall library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Combination of flags referring to definitions METACALL_FLAGS_* </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef066c5638c4e049288d98911e1a799f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef066c5638c4e049288d98911e1a799f">&#9670;&nbsp;</a></span>metacall_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_initialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize MetaCall library. </p>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="a9c70099ab9944bc953ff0998fa92f97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c70099ab9944bc953ff0998fa92f97e">&#9670;&nbsp;</a></span>metacall_initialize_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_initialize_ex </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmetacall__initialize__configuration__type.html">metacall_initialize_configuration_type</a>&#160;</td>
          <td class="paramname"><em>initialize_config</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize MetaCall library with configuration arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initialize_config</td><td>Extension of the script to be loaded in memory with data to be injected</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="ab2759ffd9206401b14fb75d53bf35987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2759ffd9206401b14fb75d53bf35987">&#9670;&nbsp;</a></span>metacall_initialize_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void metacall_initialize_args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize MetaCall application arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of additional parameters to be passed to the runtime when initializing</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>Additional parameters to be passed to the runtime when initializing (when using MetaCall as an application) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a881a9d10167e78461635f285a788816c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881a9d10167e78461635f285a788816c">&#9670;&nbsp;</a></span>metacall_argc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_argc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of arguments in which MetaCall was initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>An integer equal or greater than zero </dd></dl>

</div>
</div>
<a id="a9c0bd7df095d9a4db05204f04fa657a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0bd7df095d9a4db05204f04fa657a3">&#9670;&nbsp;</a></span>metacall_argv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API char** metacall_argv </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the arguments in which MetaCall was initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an array of strings with the additional arguments </dd></dl>

</div>
</div>
<a id="a6e9924c55b771ae7f80d6b153ad412d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9924c55b771ae7f80d6b153ad412d3">&#9670;&nbsp;</a></span>metacall_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_is_initialized </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if script context is loaded by @tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Extension of the script (if tag is NULL, it returns the status of the whole MetaCall instance)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if context is initialized, different from zero otherwise </dd></dl>

</div>
</div>
<a id="af773258f002ae5ea241b945ae4315d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af773258f002ae5ea241b945ae4315d49">&#9670;&nbsp;</a></span>metacall_args_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API size_t metacall_args_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Amount of function call arguments supported by MetaCall. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of arguments suported </dd></dl>

</div>
</div>
<a id="a14bbd56502b7bdd53fdbe42b46aceb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bbd56502b7bdd53fdbe42b46aceb16">&#9670;&nbsp;</a></span>metacall_execution_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_execution_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a execution path defined by @path to the extension script @tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Extension of the script</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to be loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="ab6fd858391d840206fe14725c2b695e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fd858391d840206fe14725c2b695e2">&#9670;&nbsp;</a></span>metacall_execution_path_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_execution_path_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>path_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a execution path defined by @path to the extension script @tag with length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Extension of the script</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_length</td><td>Length of the extension of the tag</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to be loaded</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path_length</td><td>Length of the path</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="a4cf8160c6bdd7c5c2614b40be31ce887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf8160c6bdd7c5c2614b40be31ce887">&#9670;&nbsp;</a></span>metacall_load_from_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_load_from_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>paths</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a script from file specified by @path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Extension of the script</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paths</td><td>Path array of files</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the array @paths</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are propagated to the loader scope (i.e they will share the scope between all previously loaded files and they can collide). Otherwise, if we pass a void* pointer set to NULL, it will behave as output parameter, obtaining the reference to the created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated handle (i.e a void* pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated to the previously allocated handle, and it will behave as a in parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="aa202ac4aeb04129ab475099af696b7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa202ac4aeb04129ab475099af696b7b8">&#9670;&nbsp;</a></span>metacall_load_from_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_load_from_memory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a script from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Extension of the script</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Memory block representing the string of the script</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Memory block representing the string of the script</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are propagated to the loader scope (i.e they will share the scope between all previously loaded files and they can collide). Otherwise, if we pass a void* pointer set to NULL, it will behave as output parameter, obtaining the reference to the created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated handle (i.e a void* pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated to the previously allocated handle, and it will behave as a in parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="ae62d509141fe85874f1865f61b4075af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62d509141fe85874f1865f61b4075af">&#9670;&nbsp;</a></span>metacall_load_from_package()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_load_from_package </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a package of scrips from file specified by @path into loader defined by @extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Extension of the script</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the package</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are propagated to the loader scope (i.e they will share the scope between all previously loaded files and they can collide). Otherwise, if we pass a void* pointer set to NULL, it will behave as output parameter, obtaining the reference to the created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated handle (i.e a void* pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated to the previously allocated handle, and it will behave as a in parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="a00a0cad16a66aaaab0f2e523ee390be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a0cad16a66aaaab0f2e523ee390be3">&#9670;&nbsp;</a></span>metacall_load_from_configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_load_from_configuration </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a a list of scrips from configuration specified by @path into loader with the following format: { "language_id": "&lt;tag&gt;", "path": "&lt;path&gt;", "scripts": [ "&lt;script0&gt;", "&lt;script1&gt;", ..., "&lt;scriptN&gt;" ] }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the configuration</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">handle</td><td>Optional pointer to reference of loaded handle. If the parameter is NULL, the symbols loaded are propagated to the loader scope (i.e they will share the scope between all previously loaded files and they can collide). Otherwise, if we pass a void* pointer set to NULL, it will behave as output parameter, obtaining the reference to the created handle, which can be later on used for calling to functions of that handle. The symbols will not be propagated to the loader scope and they will be private (this prevents collisions). The last case is if we pass an already allocated handle (i.e a void* pointer pointing to an previously loaded handle), then in this case, the symbols loaded will be propagated to the previously allocated handle, and it will behave as a in parameter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to allocator will allocate the configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="afc2c0d0a24b9f6e4908bbac36d98954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2c0d0a24b9f6e4908bbac36d98954b">&#9670;&nbsp;</a></span>metacallv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by value array @args. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="ad934b33c0c04c424d7080735d86a240c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad934b33c0c04c424d7080735d86a240c">&#9670;&nbsp;</a></span>metacallv_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallv_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by value array @args. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of the call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="abaa8b58b55e753ebcb2c6ca7221261fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa8b58b55e753ebcb2c6ca7221261fe">&#9670;&nbsp;</a></span>metacallhv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallhv </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by handle @handle value array @args This function allows to avoid name collisions when calling functions by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle where the function belongs</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="a0973f34ae8081817abbcc84e54b09fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0973f34ae8081817abbcc84e54b09fcc">&#9670;&nbsp;</a></span>metacallhv_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallhv_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by handle @handle value array @args This function allows to avoid name collisions when calling functions by name Includes @size in order to allow variadic arguments or safe calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle where the function belongs</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of the call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="a927b07b0d76019322c9a84a768333be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927b07b0d76019322c9a84a768333be7">&#9670;&nbsp;</a></span>metacall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by variable arguments @va_args. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">va_args</td><td>Varidic function parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="a3d6052ad320dd2bb83d6c39d7bac3a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6052ad320dd2bb83d6c39d7bac3a1e">&#9670;&nbsp;</a></span>metacallt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by type array @ids and variable arguments @va_args. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ids</td><td>Array of types refered to @va_args</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">va_args</td><td>Varidic function parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="a93e003693bcf043424e5bd77255ef629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e003693bcf043424e5bd77255ef629">&#9670;&nbsp;</a></span>metacallt_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallt_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by type array @ids and variable arguments @va_args. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ids</td><td>Array of types refered to @va_args</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of the call</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">va_args</td><td>Varidic function parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="a020d72d3ec5fac1ef707e57e356ef0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020d72d3ec5fac1ef707e57e356ef0ea">&#9670;&nbsp;</a></span>metacallht_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallht_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by type array @ids and variable arguments @va_args. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to the handle returned by metacall_load_from_{file, memory, package}</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ids</td><td>Array of types refered to @va_args</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of the call</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">va_args</td><td>Varidic function parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="a137dbf351f620ac5c1daebf1564f099b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137dbf351f620ac5c1daebf1564f099b">&#9670;&nbsp;</a></span>metacall_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_function </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0733570d83d6daf0e421e3e414547566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0733570d83d6daf0e421e3e414547566">&#9670;&nbsp;</a></span>metacall_handle_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_handle_function </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26ff10520ec45fc6dc56e6b731f7cd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ff10520ec45fc6dc56e6b731f7cd98">&#9670;&nbsp;</a></span>metacall_function_parameter_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_function_parameter_type </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the function parameter type id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The pointer to the function obtained from metacall_function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>The index of the parameter to be retrieved</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>The parameter type id that will be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 0 if the @parameter index exists and @func is valid, 1 otherwhise </dd></dl>

</div>
</div>
<a id="a391f6f382c453d8903889a910f59bf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391f6f382c453d8903889a910f59bf4c">&#9670;&nbsp;</a></span>metacall_function_return_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_function_return_type </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the function return type id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The pointer to the function obtained from metacall_function</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>The value id of the return type of the function @func</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 0 if the @func is valid, 1 otherwhise </dd></dl>

</div>
</div>
<a id="ae41ffa4531b7819e7f0d1c580ef508c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41ffa4531b7819e7f0d1c580ef508c5">&#9670;&nbsp;</a></span>metacall_function_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API size_t metacall_function_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get minimun mumber of arguments accepted by function @func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Function reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return mumber of arguments </dd></dl>

</div>
</div>
<a id="a42f7b6d24d91f6aa2b1a1bf773a2be3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f7b6d24d91f6aa2b1a1bf773a2be3b">&#9670;&nbsp;</a></span>metacall_function_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_function_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the function @func is asynchronous or synchronous. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Function reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 0 if it is syncrhonous, 1 if it is asynchronous and -1 if the function is NULL </dd></dl>

</div>
</div>
<a id="a579d699c4407cc27e94d216303f152aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579d699c4407cc27e94d216303f152aa">&#9670;&nbsp;</a></span>metacall_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_handle </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a593872223a3cbbf9856ce9d9dc8ba2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593872223a3cbbf9856ce9d9dc8ba2da">&#9670;&nbsp;</a></span>metacall_handle_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API const char* metacall_handle_id </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of a @handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to the handle to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String that references the handle </dd></dl>

</div>
</div>
<a id="ad69cc4988cf490c58d1c5d72ce7a3f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69cc4988cf490c58d1c5d72ce7a3f95">&#9670;&nbsp;</a></span>metacall_handle_export()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_handle_export </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a value representing the handle as a map of functions (or values) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Reference to the handle to be described</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type map on success, null otherwise </dd></dl>

</div>
</div>
<a id="a7029ce54bb2a8fb4516415e42d6d986b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7029ce54bb2a8fb4516415e42d6d986b">&#9670;&nbsp;</a></span>metacallfv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfv </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by value array @args and function @func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="afcaf2d96cbe7e899e9f5450be7d7d1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcaf2d96cbe7e899e9f5450be7d7d1c4">&#9670;&nbsp;</a></span>metacallfv_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfv_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by value array @args and function @func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of function arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="ae523e9a658d5ea11bde72660df84df95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae523e9a658d5ea11bde72660df84df95">&#9670;&nbsp;</a></span>metacallf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by variable arguments @va_args and function @func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="a6de5e0d836963404a27918bfade98cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5e0d836963404a27918bfade98cad">&#9670;&nbsp;</a></span>metacallfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by function @func and serial @buffer of size @size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>String representing an array to be deserialized into arguments of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of string @buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to allocator will allocate the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="ac1ecf16f1985cecee777d9e84c70d79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ecf16f1985cecee777d9e84c70d79a">&#9670;&nbsp;</a></span>metacallfmv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfmv </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by value map (@keys -&gt; @values) and function @func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Array of values representing argument keys</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of values representing argument values data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="ae381876c35f6b194c96c19a9b808e313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae381876c35f6b194c96c19a9b808e313">&#9670;&nbsp;</a></span>metacallfms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfms </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function anonymously by function @func and serial @buffer of size @size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>String representing a map to be deserialized into arguments of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of string @buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to allocator will allocate the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="a810ca74b8efef842df8ea7baf2b87e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810ca74b8efef842df8ea7baf2b87e67">&#9670;&nbsp;</a></span>metacall_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_register </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(size_t, void *[], void *)&#160;</td>
          <td class="paramname"><em>invoke</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>return_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0f575287847cd57f5a549b2b211db1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f575287847cd57f5a549b2b211db1d">&#9670;&nbsp;</a></span>metacall_registerv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_registerv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(size_t, void *[], void *)&#160;</td>
          <td class="paramname"><em>invoke</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>return_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>types</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc4e32dfcccfefd3fec11b80f7edd10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4e32dfcccfefd3fec11b80f7edd10a">&#9670;&nbsp;</a></span>metacall_register_loaderv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_register_loaderv </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>loader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(size_t, void *[], void *)&#160;</td>
          <td class="paramname"><em>invoke</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>return_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>types</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52ef2927638d958c6e76555fc49a765b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ef2927638d958c6e76555fc49a765b">&#9670;&nbsp;</a></span>metacall_await()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_await </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>resolve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>reject_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes an asynchronous call to the function and registers a callback to be executed when a future is resolved (it does block) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the function to be called asynchronously</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to the values to be passed to the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_callback</td><td>Pointer to function that will be executed when task completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* Value representing the result of the future resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* A reference to @data that will be used as a closure for the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reject_callback</td><td>Pointer to function that will be executed when task error (signature is identical as resolve_callback)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="a5f24de215645b2728c80e20685cb5525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f24de215645b2728c80e20685cb5525">&#9670;&nbsp;</a></span>metacall_await_future()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_await_future </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>resolve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>reject_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Awaits for a promise and registers a callback to be executed when a future is resolved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The pointer to the future</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_callback</td><td>Pointer to function that will be executed when task completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* Value representing the result of the future resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* A reference to @data that will be used as a closure for the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reject_callback</td><td>Pointer to function that will be executed when task error (signature is identical as resolve_callback)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="a698f9b1a031af836302d2634e3194f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698f9b1a031af836302d2634e3194f75">&#9670;&nbsp;</a></span>metacall_await_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_await_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>resolve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>reject_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes an asynchronous call to the function and registers a callback to be executed when a future is resolved (it does block) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the function to be called asynchronously</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to the values to be passed to the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of the array @args</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_callback</td><td>Pointer to function that will be executed when task completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* Value representing the result of the future resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* A reference to @data that will be used as a closure for the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reject_callback</td><td>Pointer to function that will be executed when task error (signature is identical as resolve_callback)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="a4aae2677499d7bc7992840e90d754d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aae2677499d7bc7992840e90d754d83">&#9670;&nbsp;</a></span>metacallfv_await()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfv_await </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>resolve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>reject_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an asynchronous function anonymously by value array @args and function @func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to values</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_callback</td><td>Pointer to function that will be executed when task completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* Value representing the result of the future resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* A reference to @data that will be used as a closure for the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reject_callback</td><td>Pointer to function that will be executed when task error (signature is identical as resolve_callback)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="a9c5ead1f1aa559e58a65f69ae51972cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5ead1f1aa559e58a65f69ae51972cb">&#9670;&nbsp;</a></span>metacallfv_await_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfv_await_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>resolve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>reject_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an asynchronous function anonymously by value array @args and function @func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to values</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of the array @args</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_callback</td><td>Pointer to function that will be executed when task completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* Value representing the result of the future resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* A reference to @data that will be used as a closure for the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reject_callback</td><td>Pointer to function that will be executed when task error (signature is identical as resolve_callback)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="afe71978aefb3bb4d664ddf54b5ab81b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe71978aefb3bb4d664ddf54b5ab81b7">&#9670;&nbsp;</a></span>metacallfv_await_struct_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfv_await_struct_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmetacall__await__callbacks.html">metacall_await_callbacks</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an asynchronous function anonymously by value array @args and function @func (offered without function pointers for languages without support to function pointers) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to values</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of the array @args</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Pointer to struct containing the function pointers to reject and resolve that will be executed when task completion or error</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="a806b1dda95f596de33a9527123fed8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806b1dda95f596de33a9527123fed8e4">&#9670;&nbsp;</a></span>metacallfmv_await()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfmv_await </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>resolve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>reject_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an asynchronous function anonymously by value map (@keys -&gt; @values) and function @func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Array of values representing argument keys</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of values representing argument values data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of the arrays @keys and @values</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_callback</td><td>Pointer to function that will be executed when task completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* Value representing the result of the future resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* A reference to @data that will be used as a closure for the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reject_callback</td><td>Pointer to function that will be executed when task error (signature is identical as resolve_callback)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="a4c8d0fa0f6b7c3607bd92524a11f3c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8d0fa0f6b7c3607bd92524a11f3c5c">&#9670;&nbsp;</a></span>metacallfmv_await_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfmv_await_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>resolve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>reject_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an asynchronous function anonymously by value map (@keys -&gt; @values) and function @func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Array of values representing argument keys</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Array of values representing argument values data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_callback</td><td>Pointer to function that will be executed when task completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* Value representing the result of the future resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* A reference to @data that will be used as a closure for the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reject_callback</td><td>Pointer to function that will be executed when task error (signature is identical as resolve_callback)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="addd2e38b4966b41bc2473c172d52147d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd2e38b4966b41bc2473c172d52147d">&#9670;&nbsp;</a></span>metacallfs_await()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfs_await </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>resolve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>reject_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an asynchronous function anonymously by function @func and serial @buffer of size @size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>String representing an array to be deserialized into arguments of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of string @buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to allocator will allocate the value</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_callback</td><td>Pointer to function that will be executed when task completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* Value representing the result of the future resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* A reference to @data that will be used as a closure for the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reject_callback</td><td>Pointer to function that will be executed when task error (signature is identical as resolve_callback)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="a6111e7af53fb3dcf04018aa7a06b01e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6111e7af53fb3dcf04018aa7a06b01e3">&#9670;&nbsp;</a></span>metacallfms_await()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallfms_await </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>resolve_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>reject_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an asynchronous function anonymously by function @func and serial @buffer of size @size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Reference to function to be called</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>String representing a map to be deserialized into arguments of the function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of string @buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to allocator will allocate the value</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_callback</td><td>Pointer to function that will be executed when task completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* Value representing the result of the future resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void</td><td>* A reference to @data that will be used as a closure for the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value containing the result of the operation, it will be wrapped into a future later on to be returned by the function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reject_callback</td><td>Pointer to function that will be executed when task error (signature is identical as resolve_callback)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a context that will act as a closure for the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call returned by @resolve_callback or @reject_callback wrapped in a future </dd></dl>

</div>
</div>
<a id="a62422ba9010c261547585dc014f5f71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62422ba9010c261547585dc014f5f71f">&#9670;&nbsp;</a></span>metacall_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_class </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97f50d305c683edfbeec022d41d8b749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f50d305c683edfbeec022d41d8b749">&#9670;&nbsp;</a></span>metacallv_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallv_class </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a class method anonymously by value array @args (this procedure assumes there's no overloaded methods and does type conversion on values) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cls</td><td>Pointer to the class</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the method</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of args array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="ac0e15e8ca121a9b0c5b1f22f760d7137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e15e8ca121a9b0c5b1f22f760d7137">&#9670;&nbsp;</a></span>metacallt_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallt_class </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a class method anonymously by value array @args and return value type @ret (helps to resolve overloading methods) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cls</td><td>Pointer to the class</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the method</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>Type of the return value of the method</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of args array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="aee922f6a17e2d304c8074342779205c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee922f6a17e2d304c8074342779205c1">&#9670;&nbsp;</a></span>metacall_class_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_class_new </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new object instance from @cls by value array @args. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cls</td><td>Pointer to the class</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the new object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers constructor parameters</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of constructor parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new object value instance </dd></dl>

</div>
</div>
<a id="a70337e2f826dab637d640337404831cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70337e2f826dab637d640337404831cf">&#9670;&nbsp;</a></span>metacall_class_static_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_class_static_get </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an attribute from @cls by @key name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cls</td><td>Pointer to the class</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Name of the attribute to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the class attribute value or NULL if an error occurred </dd></dl>

</div>
</div>
<a id="ad69032d3eec3834b36d907141f32332a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69032d3eec3834b36d907141f32332a">&#9670;&nbsp;</a></span>metacall_class_static_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_class_static_set </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an attribute to @cls by @key name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cls</td><td>Pointer to the class</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Name of the attribute to set</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero integer if an error ocurred </dd></dl>

</div>
</div>
<a id="a1b346165cc3e9d4c958bf92c65f71ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b346165cc3e9d4c958bf92c65f71ef5">&#9670;&nbsp;</a></span>metacallv_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallv_object </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an object method anonymously by value array @args. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>Pointer to the object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the method</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of args array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="a1391d4d2e8f9dc919ecb6ce5ac00916f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1391d4d2e8f9dc919ecb6ce5ac00916f">&#9670;&nbsp;</a></span>metacallt_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacallt_object </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="metacall__value_8h.html#a09df370b94fa034a58dc8048e14ed34d">metacall_value_id</a>&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a object method anonymously by value array @args and return value type @ret (helps to resolve overloading methods) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>Pointer to the object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the method</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>Type of the return value of the method</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Array of pointers to data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements of args array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to value containing the result of the call </dd></dl>

</div>
</div>
<a id="abf765af19df6abca9ef981ed56db6b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf765af19df6abca9ef981ed56db6b92">&#9670;&nbsp;</a></span>metacall_object_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_object_get </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an attribute from @obj by @key name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>Pointer to the object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Name of the attribute to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the object attribute value or NULL if an error occurred </dd></dl>

</div>
</div>
<a id="a567cbdd3c398e4bcfab8e07ff76de06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567cbdd3c398e4bcfab8e07ff76de06b">&#9670;&nbsp;</a></span>metacall_object_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_object_set </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an attribute to @obj by @key name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>Pointer to the object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Name of the attribute to set</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero integer if an error ocurred </dd></dl>

</div>
</div>
<a id="a7e1d1400dc0a308eff0ad61495aece15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1d1400dc0a308eff0ad61495aece15">&#9670;&nbsp;</a></span>metacall_throwable_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_throwable_value </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>th</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value contained by throwable object @th. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">th</td><td>Pointer to the throwable object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the value inside of the throwable or NULL in case of error </dd></dl>

</div>
</div>
<a id="ab9d6a8fa4d186f14741ef15015798eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d6a8fa4d186f14741ef15015798eb0">&#9670;&nbsp;</a></span>metacall_inspect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API char* metacall_inspect </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide information about all loaded objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Size in bytes of return buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to allocator will allocate the string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing introspection information </dd></dl>

</div>
</div>
<a id="a640b7fe3b2b8b119abc047f3e7a3e2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640b7fe3b2b8b119abc047f3e7a3e2bf">&#9670;&nbsp;</a></span>metacall_inspect_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_inspect_value </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide information about all loaded objects as a value. </p>
<dl class="section return"><dt>Returns</dt><dd>Value containing introspection information </dd></dl>

</div>
</div>
<a id="acdcbeeeafdc83e9b69937265a0da53c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdcbeeeafdc83e9b69937265a0da53c3">&#9670;&nbsp;</a></span>metacall_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API char* metacall_serialize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the value @v to serialized string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the serial to be used</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Reference to the value</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Size of new allocated string</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to allocator will allocate the string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New allocated string containing stringified value </dd></dl>

</div>
</div>
<a id="a0d45c99a4491e8bbad9d66aa8e719e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d45c99a4491e8bbad9d66aa8e719e54">&#9670;&nbsp;</a></span>metacall_deserialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_deserialize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the string @buffer to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the serial to be used</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>String to be deserialized</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of string @buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Pointer to allocator will allocate the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New allocated value representing the string (must be freed) </dd></dl>

</div>
</div>
<a id="ae1f35c9c5cd2b375e8fb00b9d8c5890c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f35c9c5cd2b375e8fb00b9d8c5890c">&#9670;&nbsp;</a></span>metacall_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_clear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear handle from memory and unload related resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Reference to the handle to be unloaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="a57ecb3af9057cf7c9457bab16b0958ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ecb3af9057cf7c9457bab16b0958ac">&#9670;&nbsp;</a></span>metacall_plugin_extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_plugin_extension </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the plugin extension handle to be used for loading plugins. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the extension handle, or null if it failed to load </dd></dl>

</div>
</div>
<a id="aa2add9c2e53f0bbd664392ada75cd5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2add9c2e53f0bbd664392ada75cd5b0">&#9670;&nbsp;</a></span>metacall_plugin_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API const char* metacall_plugin_path </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the plugin extension path to be used for accessing the plugins folder. </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the core plugin path, or null if it failed to load the plugin extension </dd></dl>

</div>
</div>
<a id="aca8745a9f261bc3d37ee9156b991296f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8745a9f261bc3d37ee9156b991296f">&#9670;&nbsp;</a></span>metacall_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API int metacall_destroy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy MetaCall library. </p>
<dl class="section return"><dt>Returns</dt><dd>Zero if success, different from zero otherwise </dd></dl>

</div>
</div>
<a id="a1193b3c37aee3b2f5ed49b1e08784ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1193b3c37aee3b2f5ed49b1e08784ffd">&#9670;&nbsp;</a></span>metacall_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API const struct <a class="el" href="structmetacall__version__type.html">metacall_version_type</a>* metacall_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the module version struct. </p>
<dl class="section return"><dt>Returns</dt><dd>Static struct containing unpacked version </dd></dl>

</div>
</div>
<a id="a3af1b1656bce5952ccd86352bdd76bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af1b1656bce5952ccd86352bdd76bb0">&#9670;&nbsp;</a></span>metacall_version_hex_make()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API uint32_t metacall_version_hex_make </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the module version hexadecimal value with format 0xMMIIPPPP where M is @major, I is @minor and P is @patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">major</td><td>Unsigned integer representing major version</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minor</td><td>Unsigned integer representing minor version</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>Unsigned integer representing patch version</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal integer containing packed version </dd></dl>

</div>
</div>
<a id="a81a1feba31ad43cd3dda3d08699e1780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a1feba31ad43cd3dda3d08699e1780">&#9670;&nbsp;</a></span>metacall_version_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API uint32_t metacall_version_hex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the module version hexadecimal value with format 0xMMIIPPPP where M is major, I is minor and P is patch. </p>
<dl class="section return"><dt>Returns</dt><dd>Hexadecimal integer containing packed version </dd></dl>

</div>
</div>
<a id="a8c0fd2d5fca3f94b8d52e2fa7ee79788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0fd2d5fca3f94b8d52e2fa7ee79788">&#9670;&nbsp;</a></span>metacall_version_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API const char* metacall_version_str </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the module version string. </p>
<dl class="section return"><dt>Returns</dt><dd>Static string containing module version </dd></dl>

</div>
</div>
<a id="ab7beb4c0175a8e98b445bb0bc2218dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7beb4c0175a8e98b445bb0bc2218dba">&#9670;&nbsp;</a></span>metacall_version_revision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API const char* metacall_version_revision </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the module version revision string. </p>
<dl class="section return"><dt>Returns</dt><dd>Static string containing module version revision </dd></dl>

</div>
</div>
<a id="a8c2bfc0f3461385a84c61e4142d3bc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2bfc0f3461385a84c61e4142d3bc47">&#9670;&nbsp;</a></span>metacall_version_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API const char* metacall_version_name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the module version name. </p>
<dl class="section return"><dt>Returns</dt><dd>Static string containing module version name </dd></dl>

</div>
</div>
<a id="a47d8e1e26509c0c775ba0ecbd08f9288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d8e1e26509c0c775ba0ecbd08f9288">&#9670;&nbsp;</a></span>metacall_print_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API const char* metacall_print_info </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the module information. </p>
<dl class="section return"><dt>Returns</dt><dd>Static string containing module information </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad50602b5115964e06b18483807ba1e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50602b5115964e06b18483807ba1e11">&#9670;&nbsp;</a></span>metacall_null_args</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">METACALL_API void* metacall_null_args[1]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_e44cd7e635bb763401c0caf0a476eb95.html">metacall</a></li><li class="navelem"><a class="el" href="dir_862189cd8eef5d16f2384f5f677984a6.html">include</a></li><li class="navelem"><a class="el" href="dir_89c17dc2999f746bfb4b59fe5ba3359a.html">metacall</a></li><li class="navelem"><a class="el" href="metacall_8h.html">metacall.h</a></li>
    <li class="footer">Generated on Thu Feb 8 2024 10:10:16 for MetaCall by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
